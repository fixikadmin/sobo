{"pages":[{"url":"blog/posts/2019/05/08/autossh-tunell-in-ubuntu/","text":"INTRO Tunelul SSH este util atunci cind nu este posibil de a face un canal VPN intre doua masini. Aceasta limitare poate fin impusa de operatorul Internet, cit si de alte echipamente de retea sau firewall. In acest articol voi aduce exemple cum poate fi creat un astfel de tunel. In primul rind ca conditie, este necesar sa avem SSH instalat pe ambele servere. COMENZI UTILE O comanda simpla de a crea un tunel este: ssh -R 5555:localhost:22 user@host unde: 5555 - portul de la distanta pe care va fi accesibil tunelui 22 - portul local pe care este accesibil serviciul necesar tunelarii (spre exemplu SSH (22)) localhost - interfata pe care esre ridicat acest tunel user - contul SSH host - hostame-ul serverului remote Pe serverul remote vom avea: netstat -lntp | grep 5555 tcp 0 0 127.0.0.1:5555 0.0.0.0:* LISTEN 11976/sshd: root@pt Putem testa tunelul cu telnet (de pe masina de la distanta) telnet localhost 5555 root@host:~# telnet localhost 5555 Trying 127.0.0.1... Connected to localhost. Escape character is '&#94;]'. SSH-2.0-OpenSSH_7.6p1 Ubuntu-4ubuntu0.3 Vedem ca ne putem conecta prin SSH la masia na remote AUTOMATIZAREA CONEXIUNII La acest capitol vom descrie unele etape de automatizare: Vom simplifica crearea tunelului prin adaugarea cheilor SSH . Vom configura SSH pentru a folosi nume generice in loc de IP -uri si cheile publice respective. Deasemenea vom folosi autossh care are ca functia de a mentine tunelul SSH in stare activa. Vom crea un script de serviciu care se va lansa la startarea SSH . Adugam cheile SSH Ca sa nu introducem de fiecare data IP adresa masinii remote in fisierul /etc/hosts adugam 12.34.56.78 host Generam cheia SSH pe masina locala ssh-keygen -t rsa In folderul ~/.ssh/ vor fi createa cheia publica si privata -rw------- 1 root root 1679 Mar 4 13:49 id_rsa -rw-r--r-- 1 root root 391 Mar 4 13:49 id_rsa.pub In continuare avem nevoie de id_rsa.pub care contine cheia publica. Continutul acestui fisier id_rsa.pub se va copia pe serverul destinatie, in fisierul ~/.ssh/authorized_keys Astfel conexiunea SSH va fi stabilita prin comanda ssh root@host Parola nu va fi ceruta pentru a stabili conexiunea. Daca vrem sa folosim o cheie diferita de cea default foslosim: ssh -i /path/to/key/id_rsa user@host In comanda de mai sus se indica cheia privata Configurarea SSH prin utilizarea numelor generice In directorul ~/.ssh/ cream fisierul config nano config In care punem urmatoarele: Host remo ## denumirea scurta a hostului HostName host ## denumirea generica inclusa in /etc/hosts User root ## username Port 22 ## portul remote pe care asculta SSH IdentityFile ~/.ssh/id_rsa ## cheia privata generata anterior RemoteForward 5555 localhost:22 ## comanda ce va crea tunelul ServerAliveInterval 30 ## timpul in care va fi verificata conexiunea ServerAliveCountMax 3 ## numarul de incercari esuate de stabilire a conexiunii Astfel putem efectua comanda simpla ssh remo Respectiv va fi creat tunelul si ne vom loga pe serverul destinatie. Insa noi nu avem nevoie sa ne logam pe serverul de la distanta Instalarea si configurarea autossh Instalam pachetele necesare apt-get install autossh Cream tunelul din linia de comanda autossh -L 5555:localhost:22 user@host sau autossh -M 0 -o \"ServerAliveInterval 30\" -o \"ServerAliveCountMax 3\" -NR 5555:localhost:22 user@host -p 22 SURSE [1] https://www.everythingcli.org/ssh-tunnelling-for-fun-and-profit-autossh/","tags":"Admin","title":"Crearea tunelului SSH"},{"url":"blog/posts/2019/05/08/vnc-server-in-ubuntu/","text":"Instalarea Se presupune ca avem instalata o interfata grafica , de ex. XFCE , LXDE , LXQT , MATE , sau chiar OpenBox Instalam pachetele pentru vncserver sudo apt update apt install tightvncserver Pentru a finisa configurarea serverului VNC efectuam urmatoaraea comanda care va seta parola de access vncserver Rezultat Show/hide You will require a password to access your desktops. Password: Warning: password truncated to the length of 8. Verify: Would you like to enter a view-only password (y/n)? n xauth: file /root/.Xauthority does not exist New 'X' desktop is farm:1 Creating default startup script /root/.vnc/xstartup Starting applications specified in /root/.vnc/xstartup Log file is /root/.vnc/farm:1.log Parola poate fi modificata si cu comanda vnpasswd Configurarea Serverul VNC trebuie sa stie ce comenzi trebuie executate la pornire. Mai exact, VNC trebuie sa stie pe care desktop grafic trebuie sa se conecteze. Aceste comenzi sunt localizate intr-un fisier de configurare numit xstartup in directorul .vnc din directorul ~ adica HOME . Scriptul de pornire a fost creat cand a fost executata comanda vncserver din capitolul precedent, dar noi vom crea propriul nostru script pentru a lansa interfata LXDE . Atunci cand VNC este lansat pentru prima data, aceasta asculta pe portul 5901. Acest port este numit port de afisare si este desemnat de VNC ca fiind :1. VNC se poate lansa pe mai multe porturi in diferite instante, cum ar fi :2, :3 si asa mai departe. Ca sa oprim VNC serverul folosim comanda: vncserver -kill :1 Rezultat Show/hide Killing Xtightvnc process ID 17648 Pina a modifica scriptul xstartup , facem pentru acesta o copie de rezerva: mv ~/.vnc/xstartup ~/.vnc/xstartup.bak Cream scriptul nostru de start-up al serverului VNC nano ~/.vnc/xstartup Punem urmatorul continut in acesta (Pentru LXDE ) 1 2 3 4 5 6 7 #!/bin/sh [ -x /etc/vnc/xstartup ] && exec /etc/vnc/xstartup [ -r $HOME /.Xresources ] && xrdb $HOME /.Xresources xsetroot -solid grey vncconfig -iconic & x-terminal-emulator -geometry 80x24+10+10 -ls -title \" $VNCDESKTOP Desktop\" & /usr/bin/startlxde Pentru XFCE 1 2 3 #!/bin/bash xrdb $HOME /.Xresources startxfce4 & Salvam si dam drepturi de executie chmod +x ~/.vnc/xstartup Startam VNC serverul vncserver Startarea automata la lansarea OS Pentru a lansa automat serverul VNC trebuie sa cream scritul de lansare nano /etc/systemd/system/vncserver@.service Punem urmatorul continut: [Unit] Description = Start TightVNC server at startup After = syslog.target network.target [Service] Type = forking User = user Group = user WorkingDirectory = /home/user PIDFile = /home/user/.vnc/%H:%i.pid ExecStartPre = -/usr/bin/vncserver -kill :%i > /dev/null 2>&1 ExecStart = /usr/bin/vncserver -depth 24 -geometry 1280x800 :%i ExecStop = /usr/bin/vncserver -kill :%i [Install] WantedBy = multi-user.target Actualizam systemctl daemon-reload Punem in start-up systemctl enable vncserver @1. service Surse [1] https://www.digitalocean.com/community/tutorials/how-to-install-and-configure-vnc-on-ubuntu-18-04 [2] https://www.127001.ro/node/37","tags":"Admin","title":"Serverul VNC pentru access la distanta"},{"url":"blog/posts/2019/02/27/usefull-commands-elasticsearch/","text":"Intro In acest post voi pune niste comenzi utile Elasticsearch. Aceste ccomenzi pot fi rulate in Kibana â€”> Dev Tools Comenzi utile Arata statistica la indecsii \"Logstash\" GET /_cat/indices/logstash*?v&s=index Arata index-urile dupa numarul de documente - in descrestere GET _cat/indices?v&s=docs.count:desc Arata index-urile dupa volum - in descrestere GET _cat/indices?v&s=store.size:desc Arata index-urile dupa memoria RAM folosita - in descrestere GET _cat/indices?v&h=i,tm&s=tm:desc Statutul Clusterului Elasticsearch GET _cluster/health?pretty Toti indecsii cu statut YELLOW GET /_cat/indices?v&health=yellow Arata setarile indexului GET /logstash-2017.12.07/_settings Eliminarea indexului DELETE /logstash-2017.02.03 Surse [1] http://www.elasticsearch.org/guide/reference/api/delete-by-query","tags":"Elastic","title":"Comenzi utile in Elasticsearch"},{"url":"blog/posts/2019/02/27/zimbra-security/","text":"INTRO SCRIPT .. raw:: html REFERINTE : [1] https://stackoverflow.com/questions/28706806/pelican-external-image-in-restructured-text","tags":"Zimbra","title":"Securitatea in Zimbra OSE"},{"url":"blog/posts/2018/10/20/notificarea-utilizatorilo-despre-expirarea-parolei/","text":"INTRO In instalatia default Zimbra notificarea catre utilizatori care informeaza utilizatorul despre expirarea parolei sale nu este transmis. Astfel utilizatorul este nevoit sa apeleze la administratorul serviciului de posta electronica cu rugamintea de ai reseta parola (In cazul ca nu o cunoaste). Utilizatorii MS Outlook primesc eroare la conectare. In acest caz folosim un script Bash care in vom pune in cron, pentru a rula in fiecare zi. SCRIPT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/bin/bash FROM = \"postmaster@zimbra.md\" DOMAIN = \"zimbra.md\" SENDMAIL = $( ionice -c3 find /opt/zimbra/ -type f -iname sendmail ) USERS = ` /opt/zimbra/bin/zmprov -l gaa | grep -v \"galsync\" | grep -v \"zimbra.md\" ` ; DATE = $( date +%s ) for USER in $USERS do OBJECT = \"(&(objectClass=zimbraAccount)(mail= $USER ))\" ZIMBRA_LDAP_PASSWORD = ` su - zimbra -c \"zmlocalconfig -s zimbra_ldap_password | cut -d ' ' -f3\" ` LDAP_MASTER_URL = ` su - zimbra -c \"zmlocalconfig -s ldap_master_url | cut -d ' ' -f3\" ` LDAPSEARCH = $( ionice -c3 find /opt/zimbra/ -type f -iname ldapsearch ) PASS_SET_DATE = ` $LDAPSEARCH -H $LDAP_MASTER_URL -w $ZIMBRA_LDAP_PASSWORD -D uid = zimbra,cn = admins,cn = zimbra \\ -x $OBJECT | grep zimbraPasswordModifiedTime: | cut -d \" \" -f 2 | cut -c 1 -8 ` EXPIRES = $( date -d \" $PASS_SET_DATE 60 days\" +%s ) DEADLINE = $(( (( $DATE - $EXPIRES )) / -86400 )) SUBJECT = \" $USER - Parola contului DVS. e-mail expira in $DEADLINE zile\" BODY = \" Stimate client, detinator al adresei e-mail $USER , Va anuntam ca parola dvs. de e-mail va expira in $DEADLINE zile. Va rugam sa modificati parola e-mail \\ prin Web Mail: - Adresa : https:// $DOMAIN 1. Conectati-va la Web Mail prin adresa de mai sus 2. Selectati fila Preferinte 3. Faceti clic pe butonul Modifica parola 4. Completati parola veche, noua parola si confirmati noua parola 5. Faceti clic pe Modificare parola pentru a o schimba Parola contului e-mail trebuie sa contina de cel putin 8 caractere, cu o combinatie de caractere alfanumerice \\ (majuscule, litere mici, numere) si simboluri (! @ # $ , Etc.). Daca aveti intrebari cu privire la modul de a schimba parola de e-mail, va rugam sa contactati echipa de asistenta \\ la nr. de tel. x(xx)xxxxxx Multumim, echipa Zimbra.md \" if [[ \" $DEADLINE \" -eq \"5\" ]] then echo \"Subject: $SUBJECT \" \" $BODY \" | $SENDMAIL -f \" $FROM \" \" $USER \" echo \"Reminder email sent to: $USER - $DEADLINE days left\" elif [[ \" $DEADLINE \" -eq \"3\" ]] then echo \"Subject: $SUBJECT \" \" $BODY \" | $SENDMAIL -f \" $FROM \" \" $USER \" echo \"Reminder email sent to: $USER - $DEADLINE days left\" elif [[ \" $DEADLINE \" -eq \"1\" ]] then echo \"Subject: $SUBJECT \" \" $BODY \" | $SENDMAIL -f \" $FROM \" \" $USER \" echo \"Last chance for: $USER - $DEADLINE days left\" else echo \"Account: $USER reports; $DEADLINE days on Password policy\" fi done REFERINTE : [1] https://imanudin.net/2017/02/04/script-notify-expired-password-on-zimbra [2] https://github.com/wuxmedia/Zimbra_passpoll/blob/master/passpoll.sh","tags":"Zimbra","title":"Notificarea utilizatorilor despre expirarea parolei"},{"url":"blog/posts/2018/10/18/exportarea-drepturilor-administrator-delegat-zimbra/","text":"Problem Export grants & views of a delegated admin and create a new delegated admin with the same grants & views Solution Note: This is only applicable for legacy admin module and does not apply for Zimbra NG module. Here we have an existing delegated admin \"myadmin@ DOMAIN . COM \" and we will create a new delegated admin â€˜\"newadmin@ DOMAIN . COM \" with the same views and grants. 1). Check enabled views of existing delegated admin:- zmprov -l ga myadmin@DOMAIN.COM | egrep -i 'zimbraAdminConsoleUIComponents|zimbraIsDelegatedAdminAccount:' Output:- zimbraAdminConsoleUIComponents : accountListView zimbraAdminConsoleUIComponents : downloadsView zimbraAdminConsoleUIComponents : DLListView zimbraAdminConsoleUIComponents : aliasListView zimbraAdminConsoleUIComponents : resourceListView zimbraAdminConsoleUIComponents : saveSearch zimbraIsDelegatedAdminAccount : TRUE 2). Check or export assigned rights of the delegated admin :- zmprov gg -g usr myadmin@DOMAIN.COM Output:- target type target id target name grantee type grantee id grantee name right ------------ ------------------------------------ ------------------ ------------ ------------------------------------ ------------------ -------------------- global globalacltarget usr 87609353-a8fb-4ed5-b750-6b538cd52f35 myadmin@DOMAIN.COM adminLoginCalendarResourceAs global globalacltarget usr 87609353-a8fb-4ed5-b750-6b538cd52f35 myadmin@DOMAIN.COM domainAdminZimletRights domain 1ccb92be-56cc-4962-b964-b07af84dc118 DOMAIN.COM usr 87609353-a8fb-4ed5-b750-6b538cd52f35 myadmin@DOMAIN.COM domainAdminConsoleRights 3). Now we have to fine tune above output for a new admin. global usr myadmin@DOMAIN.COM adminLoginCalendarResourceAs global usr myadmin@DOMAIN.COM domainAdminZimletRights domain DOMAIN.COM usr myadmin@DOMAIN.COM domainAdminConsoleRights 4). Create a file \"/tmp/grants.txt\" with the exported grants and replace old admin name with new delegated admin. Prepare exported grant file for new delegated admin (newadmin@ DOMAIN . COM ). The file must have grants in the following format:- grr global usr newadmin@DOMAIN.COM adminLoginCalendarResourceAs grr global usr newadmin@DOMAIN.COM domainAdminZimletRights grr domain DOMAIN.COM usr newadmin@DOMAIN.COM domainAdminConsoleRights 5). Now we will create a new delegated admin with the same views as existing admin has: - zmprov ca newadmin@DOMAIN.COM <PASSWORD> zimbraIsDelegatedAdminAccount TRUE zimbraAdminConsoleUIComponents accountListView zimbraAdminConsoleUIComponents downloadsView zimbraAdminConsoleUIComponents DLListView zimbraAdminConsoleUIComponents aliasListView zimbraAdminConsoleUIComponents resourceListView zimbraAdminConsoleUIComponents saveSearch 6). Here we will assign grants from the prepared file in Step4:- zmprov < /tmp/grants.txt 7). Now check grants of newly created delegated admin, the output of below command must be similar to the output of Step2:- zmprov gg -g usr newadmin@DOMAIN.COM Extra Notes: Some additional tips for those admins who loves to play with sed and awk:- Here we are exporting and redirecting grants to a file, and preparing grants for new delegated admin. NOTE : These steps are only for Domain and Global level grants. If there are other level grants assigned to delegated admin then use \"awk\" carefully to extract correct column. zmprov gg -g usr myadmin@DOMAIN.COM | grep &#94;global | awk '{print $1,$3,$5,$6}' >> /tmp/grants.txt zmprov gg -g usr myadmin@DOMAIN.COM | grep &#94;domain | awk '{print $1,$3,$4,$6,$7}' >> /tmp/grants.txt Check the content of the file \"/tmp/grants.txt\" and the output will look like the following:- cat /tmp/grants.txt global usr newadmin@DOMAIN.COM adminLoginCalendarResourceAs global usr newadmin@DOMAIN.COM domainAdminZimletRights domain DOMAIN.COM usr newadmin@DOMAIN.COM domainAdminConsoleRights Add \"grr\" at the beginning of each line:- sed -i 's/&#94;/grr /' /tmp/grants.txt Now file will show content in following format:- cat /tmp/grants.txt grr global usr newadmin@DOMAIN.COM adminLoginCalendarResourceAs grr global usr newadmin@DOMAIN.COM domainAdminZimletRights grr domain DOMAIN.COM usr newadmin@DOMAIN.COM domainAdminConsoleRights Replace old delegated admin email-id with new delegated admin:- sed -i 's/myadmin@DOMAIN.COM/newadmin@DOMAIN.COM/' /tmp/grants.txt Now we will assign grants to new delegated admin with prepared file /tmp/grants.txt zmprov < /tmp/grants.txt","tags":"Zimbra","title":"Export grants and views of a delegated admin"},{"url":"blog/posts/2018/10/18/open-relay-local-in-zimbra/","text":"INTRO De sub userul zimbra se face urmatoarea comanda zmprov mcf zimbraMtaSmtpdSenderLoginMaps proxy:ldap:/opt/zimbra/conf/ldap-slm.cf +zimbraMtaSmtpdSenderRestrictions reject_authenticated_sender_login_mismatch Editam fisierul /opt/zimbra/conf/zmconfigd/smtpd_sender_restrictions.cf Adaugam permit_mynetworks, reject_sender_login_mismatch Aplicam modificarile zmmtactl restart && zmconfigdctl restart Entru a adauga exceptii trebuie sa cream un fisier zmprov mcf zimbraMtaSmtpdSenderLoginMaps 'lmdb:/opt/zimbra/conf/slm-exceptions-db, proxy:ldap:/opt/zimbra/conf/ldap-slm.cf' +zimbraMtaSmtpdSenderRestrictions reject_authenticated_sender_login_mismatch Cream fisierul de exceptii /opt/zimbra/conf/slm-exceptions-db [allow to printer@zimbra.md send from alen.delon@zimbra.md] alen.delon@zimbra.md alen.delon@zimbra.md printer@zimbra.md Aplicam postmap /opt/zimbra/conf/slm-exceptions-db zmmtactl restart && zmconfigdctl restart","tags":"Zimbra","title":"Open Relay local in Zimbra"},{"url":"blog/posts/2018/09/26/send-mail-from-console/","text":"Intro Citeodata vrem sa testam functionalitatea serverului e-mail prin comenzi SMTP direct din consola. In acest caz deschidem linia de cmanda si folosim clientul Telnet , fie in Windows sie in Linux bash. Nu stu cum altii dar eu deseori nu introduc careva date in comenzile FROM , RCPT TO si atunci conexiunea se intrerupe .. Comenzi SMTP Mai jos voi da lista cu cele mai importante comenzi SMTP cu o scurta explicatie. Fiecare comanda este folosita intr-o conexiune dintre doua servere prin protocolul SMTP , pentru a putea trimite mesaje e-mail. HELO Este prima comanda SMTP cu care incepe conversatia, este urmata de numele de domeniu (hostname). EHLO O comanda alternativa pentru a incepe conversatia pe protocolul SMTP , subliniind ca serverul utilizeaza protocolul SMTP extins. MAIL FROM Cu aceasta comanda SMTP incepe transmiterea mesajului: expeditorul afiseaza adresa de e-mail sursa in campul \"De la\". RCPT TO Acesta identifica destinatarul e-mailului; daca exista mai multe, comanda este pur si simplu repetata. SIZE Aceasta comanda SMTP informeaza serverul despre dimensiunea estimata (in termeni de Bytes) a e-mailului atasat. Acesta poate fi, de asemenea, utilizat pentru a raporta dimensiunea maxima a unui mesaj care va fi acceptat de server. DATA Cu comanda DATA continutul de e-mail incepe sa fie transferat; este in general urmat de un cod de raspuns de 354 dat de server, oferind permisiunea de a incepe transmisia efectiva. VRFY Se solicita serverului sa verifice daca intr-adevar exista o anumita adresa de e-mail sau un nume de utilizator. TURN Aceasta comanda este utilizata pentru a inversa rolurile intre client si server, fara a fi nevoie sa initiati o noua conexiune. AUTH Cu ajutorul comenzii AUTH , clientul se autentifica pe server, oferindu-i numele de utilizator si parola. Este un nivel de securitate pentru a garanta o transmisie sigura. RSET Acesta comunica serverului ca transmisia de e-mail in curs va fi terminata, desi conversatia SMTP nu va fi inchisa (ca in cazul QUIT ). EXPN Aceasta comanda SMTP cere confirmarea identificarii unei liste de adrese. HELP Este o cerere a unui client pentru unele informatii care pot fi utile pentru transferul reusit al mesajului. QUIT Termina conversatia SMTP . Script Cream un fisier unde vom avea comenzile EHLO localhost AUTH LOGIN NGJsb2dAc3Rpc2MuZ292Lm1k T2VDYU1vTjEx MAIL FROM: <admin@zimbra.md> RCPT TO: <client@zimbra.md> DATA From: <admin@zimbra.md> To: <client@zimbra.md> Date: Thu, 26 Oct 2018 14:50:11 +0000 Subject: Mesaj de test Norocele !!! Have a good day! -- System . QUIT Salvam fisierul in msg.txt Executam aceasta comanda cat \"msg.txt\" |while read L; do sleep \"1\"; echo \"$L\"; done | \"nc\" -C -v \"smtp.zimbra.md\" \"25\" sau function slowcat (){ cat \"$1\" | while read ; do sleep . 05 ; echo \"$REPLY\" ; done ; } slowcat msg . txt | nc smtp . zimbra . md 25 AUTH In comenzile de mai sus a fost folosita comanda AUTH LOGIN pentru autentificare. Aceasta foloseste username-ul si parola in base64 Generam in consola hash-ul la Username si Parola perl -MMIME :: Base64 -e 'print encode_base64(\"username\");' perl -MMIME :: Base64 -e 'print encode_base64(\"password\");' Sau generam online Surse [1] https://stackoverflow.com/questions/44250054/send-email-with-netcat [2] https://www.ndchost.com/wiki/mail/test-smtp-auth-telnet","tags":"Admin","title":"Send mail from console"},{"url":"blog/posts/2018/06/22/zimbra-backup-rezervarea-cutiilor-postale-in-zimbra-foss/","text":"Cerinte fata de sistemul de back-up Zimbra FOSS : Solutie Open Source Crearea copiilor de rezerva diferentiale. Restabilirea mesajelor la cerere. (cu revenire la punctele de backup, Anual, Lunar, Saptamanal, Zilnic) Restabilirea dintr-un cont in altul. Restabilirea contului in cazul ca a fost eliminat. Spatiul minimal pe storage. Limitari ale sistemului de backup: Nu va fi posibila restabilirea mesajelor care nu sunt acoperite de punctele de backup In scopul economisirii spatiului fisierele de back-up premergatoare for fi eliminate ( ) Solutii gasite: ZMBKPOSE (Zimbra Backup Open Source Edition) DAR Cloud Snapshot Solutia de backup care corespunde cerintelor este ZMBKPOSE (Branch: rewrite_proposal_v2.0). Site-ul proiectului: https://github.com/bggo/Zmbkpose Link-ul de download: http://github.com/bggo/Zmbkpose/archive/rewrite_proposal_v2.0.zip Estimari (rata de compresie, spatiu necesar): Spatiu estimativ pe Storage care va fi necesar: Dupa testarea solutiei pentru cateva cutii postale , a fost determinat ca 2.43 GB dupa efectuarea copiei de rezerva a fost obtinut 1. 3GB , respectiv obtinem o rata de 53% . Solutia ZMBKPOSE utilizeaza compresia GZIP + TAR , in documentatia oficiala rata de compresie este in limita 21-26%. Rezultatul din exemplu arata ca in copia de rezerva sunt prezente alte arhive care nu vor fi compresate. Timpul de compresie Acest parametru depinde de mai multi factori: specificatia hardware, incarcarea sistemului ( LA ), 2.43 GB au fost arhivate in 360s Mai jos este prezentat graficul de utilizare al CPU la arhivarea unui volum mai mare , cca 18GB Estimativ volumul total al mailbox-urilor de pe serverul meu este de cca. 195GB , care va fi compresat in 103GB timp de 6 ore si 20 min. Real volumul de 195 GB a fost compresat in 158G si a durat 7 ore (de la ora 9 pina la 16, cu intreruperi) Continuitatea serviciului de rezervare - CRON Crontab-ul pentru crearea copiilor de rezerva pentru toate conturile e-mail SHELL=/bin/bash PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root HOME=/tmp ##FULL BACKUPS every day for 400 accounts(-c 400), or for 6 hours(-C 6h) # whichever comes first, only if last full backup has more than 20 days # old(-F 20d). # Pause of 5 seconds between accounts backups( -e 5s) 0 0 * * * zimbra LOG_TYPE=full_bk /usr/local/bin/zmbkpose.wrapper -F 20d -C 6h -c 400 -e 5s ##INCREMENTAL BACKUPS every day for 3 hours(-C 3h), only if last incremental backup # has more than 30hs old(-I 30h). # Perform a full backup is not has previous incremental (-t) # Pause of 5 seconds betwee accounts backups (-e 5s) 0 6 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 9 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 18 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 21 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s #Remove old backups #Delete cycles off backups older than 15 days(-d 15d). A cycle is a full backups # and its subsequent incremental backups. # zmbkpose will not eliminate backups leaving incomplete cycles 0 2 * * * zimbra LOG_TYPE=del_bk /usr/local/bin/zmbkpose.wrapper -d 15d #Remove old logs files 0 22 * * * zimbra find /var/log/zmbkpose -type f -mtime +30 -exec rm -f '{}' \\; Explicatie: BACKUP FULL in fiecare zi pentru 400 de conturi (-c 400) sau timp de 6 ore (-6h) care apare mai intai, numai daca ultima copie de rezerva completa are mai mult de 20 de zile (Vechime 20 zile (-F 20d). Pauza de 5 secunde intre copii de rezerva ale conturilor (-e 5s) ) 0 0 * * * zimbra LOG_TYPE=full_bk /usr/local/bin/zmbkpose.wrapper -F 20d -C 6h -c 400 -e 5s BACKUP INCREMENTAL in fiecare zi timp in fiecare 3 ore (-C 3h), numai in cazul in care ultimul backup incremental are mai mult de 30 de ore vechime (-I 30h).Efectuiaza o copie de rezerva completa in caz ca nu are precedent incremental (-t) # Pauza de 5 secunde intre fie copie de backup (-e 5s) 0 6 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 9 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 18 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s 0 21 * * * zimbra LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s ELIMINARE BACKUP Elimina backup-urile mai vechi de 15 zile (-d 15d). Un ciclu este un backup complet si backup-urile ulterioare incrementale. Zmbkpose nu va elimina backup-urile care lasa cicluri incomplete 0 2 * * * zimbra LOG_TYPE=del_bk /usr/local/bin/zmbkpose.wrapper -d 15d Termeni: Backup Full Backup Full Conditionat Backup Incremental Backup Incremental Conditionat Ciclu de Backup Ciclul de backup reprezinta un backup FULL (total) si subsecventele de backup INC (incremental). Ciclul complet trebuie sa fie intre data de \"prezent\" argumentul \"-d\" de exemplu: Ziua | Backup 1 FULL 2 INC 3 INC 4 INC 5 FULL 6 INC 7 FULL 8 FULL In exemplul de mai sus avem 2 cicluri (1 ciclu Â– ziua 1-5, 2 ciclu Â– ziua 5-7 ) Atunci cand in ziua a 9-a executam zmbkpose cu cheile: -d 2d => backup-urile pentru zilele 1,2,3,4,5,6 vor fi eliminate deoarece ele sunt create mai devreme de 7 zile (9 - 2 = 7) -d 4d => backup-urile pentru zilele 1,2,3,4 vor fi eliminate deoarece ele sunt create mai devreme de 5 zile (9 - 4 = 5) -d 5d => nu va fi eliminate nici un fisier de backup deoarece aceasta va duce intreruperea ciclului de la 1 la 4 Comenzi utile: Listarea backup-urilor su - zimbra -c '/usr/local/bin/zmbkpose -l -a user@example.md' Rezultat: user@example.md \"09/06/2017 17:09:19\" FULL 1G user@example.md \"12/06/2017 10:21:07\" INC 1M user@example.md \"13/06/2017 09:09:33\" INC 650K user@example.md \"03/08/2017 16:18:00\" INC 25M user@example.md \"29/08/2017 15:22:15\" FULL 1G user@example.md \"29/08/2017 16:50:54\" INC 40K Eliminarea backup-ului (vor fi eliminate backup-urile mai vechi de o luna ) su - zimbra -c '/usr/local/bin/zmbkpose -d 1m -a user@example.md' Rezultat: 2017-08-30 10:49:50 DEBUG: user@example.md - START deleting old backups cycles prior to 30/08/2017 10:48:50 2017-08-30 10:49:50 DEBUG: user@example.md - Deleting backup from 09/06/2017 17:09:19 FULL 2017-08-30 10:49:50 DEBUG: user@example.md - Deleting backup from 12/06/2017 10:21:07 INC 2017-08-30 10:49:50 DEBUG: user@example.md - Deleting backup from 13/06/2017 09:09:33 INC 2017-08-30 10:49:50 DEBUG: user@example.md - Deleting backup from 03/08/2017 16:18:00 INC 2017-08-30 10:49:50 DEBUG: user@example.md - END deleting old backups Restabilirea contului a. Restabilirea ultimelor backup-uri (Va fi restabilit ultimul ciclu FULL + INC (1)+ INC (2)+â€¦ INC (n+1)) su - zimbra -c '/usr/local/bin/zmbkpose -r -a user@example.md' Rezultat: 2017-08-30 10:55:01 DEBUG: Testing ldapserver ldap://172.28.92.3:389, using user uid=zimbra,cn=admins,cn=zimbra 2017-08-30 10:55:01 DEBUG: user@example.md - Using ldap data from backup /opt/zimbra/backup/example.md/user/20170829165054:INC.tar 2017-08-30 10:55:01 DEBUG: user@example.md - Ldap restore started 2017-08-30 10:55:01 DEBUG: user@example.md - Mailbox restore started 2017-08-30 10:55:01 DEBUG: user@example.md - Restauring from 29/08/2017 15:22:15 FULL 2017-08-30 10:55:01 DEBUG: user@example.md - Restauring from 29/08/2017 16:50:54 INC 2017-08-30 0:55:01 DEBUG: user@example.md - Restore end b. Restabilirea conditionata (Vor fi restabilite mesajele din toate backu-urile) su - zimbra -c '/usr/local/bin/zmbkpose -R - -a user@example.md' Rezultat: 2017-08-30 11:08:32 DEBUG: Testing ldapserver ldap://172.28.92.3:389, using user uid=zimbra,cn=admins,cn=zimbra 2017-08-30 11:08:32 DEBUG: user@example.md - Using ldap data from backup /opt/zimbra/backup/example.md/user/20170829165054:INC.tar 2017-08-30 11:08:32 DEBUG: user@example.md - Ldap restore started 2017-08-30 11:08:32 DEBUG: user@example.md - Mailbox restore started 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 09/06/2017 17:09:19 FULL 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 12/06/2017 10:21:07 INC 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 13/06/2017 09:09:33 INC 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 03/08/2017 16:18:00 INC 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 29/08/2017 15:22:15 FULL 2017-08-30 11:08:32 DEBUG: user@example.md - Restauring from 29/08/2017 16:50:54 INC 2017-08-30 1:08:32 DEBUG: user@example.md - Restore end c. Restabilirea conditionata (Vor fi restabilite mesajele la data de 03/08/2017 16:18:00) su - zimbra -c '/usr/local/bin/zmbkpose -R 20170803161800 -a user@example.md' 2017-08-30 11:39:50 DEBUG: Testing ldapserver ldap://172.28.92.3:389, using user uid=zimbra,cn=admins,cn=zimbra 2017-08-30 11:39:50 DEBUG: user@example.md - Using ldap data from backup /opt/zimbra/backup/example.md/user/20170803161800:INC.tar 2017-08-30 11:39:50 DEBUG: user@example.md - Ldap restore started 2017-08-30 11:39:50 DEBUG: user@example.md - Mailbox restore started 2017-08-30 11:39:50 DEBUG: user@example.md - Restauring from 09/06/2017 17:09:19 FULL 2017-08-30 11:39:50 DEBUG: user@example.md - Restauring from 12/06/2017 10:21:07 INC 2017-08-30 11:39:50 DEBUG: user@example.md - Restauring from 13/06/2017 09:09:33 INC 2017-08-30 11:39:50 DEBUG: user@example.md - Restauring from 03/08/2017 16:18:00 INC 2017-08-30 11:39:50 DEBUG: user@example.md - Restore end Instalare: Se download-eaza scriptul de pe: h #cd /opt/kit/ #wget http://github.com/bggo/Zmbkpose/archive/rewrite_proposal_v2.0.zip Se de arhiveaza arhiva #unzip rewrite_proposal_v2.0.zip Se trece in directorul de arhivat #cd Zmbkpose-rewrite_proposal_v2.0/ Se instaleaza #./install.sh Rezultatul executiei : Checking zimbra installation ...[OK] -zmbkpose will use \"zimbra\" user for execution. Checking installer integrity ...[OK] Checking system for dependencies... ... -Dependencies will be executed by \"zimbra\" user awk ...[OK] curl ...[OK] date ...[OK] du ...[OK] egrep ...[OK] find ...[OK] grep ...[OK] ldapadd ...[OK] ldapdelete ...[OK] ldapsearch ...[OK] ln ...[OK] printf ...[OK] rm ...[OK] sed ...[OK] sort ...[OK] tar ...[OK] uniq ...[OK] readlink ...[OK] Installing ...[OK] ################################################################################ I configured /etc/zmbkpose/zmbkpose.conf whith : WORKDIR=\"/opt/zimbra/backup\" Change it if you decide to place the backup files elsewhere. ################################################################################ If you want, I can try configure /etc/zmbkpose/zmbkpose.conf with the following settings automatically detected: * LDAPMASTERSERVER=ldap://192.168.0.1:389 * LDAPZIMBRADN=uid=zimbra,cn=admins,cn=zimbra * LDAPZIMBRAPASS=WyZ3nfKd Do you like this script make these settings? [y/n]: [YES] ################################################################################ You will need to configure the follow values manually in /etc/zmbkpose/zmbkpose.conf before to use zmbkpose: * ADMINUSER * ADMINPASS The following users were found as administrators, and can be configured as ADMINUSER: * admin@example.md ################################################################################ Note: -------------------------------------------------------------------------- Remember execute zmbkpose using user \"zimbra\", dependent commands were checked using this user. -------------------------------------------------------------------------------- Install completed. Do you want to display the README file? [y/n]: [NO] Configurare: In /etc/zmbkpose/zmbkpose.conf se afla configurarile: WORKDIR=\"/opt/zimbra/backup\" - directorul unde se va face backup (este creat automat la instalare) ADMINUSER=zmbkpose@example.md.md - cont de administrator ADMINPASS=password - parola contului de administrator LDAPMASTERSERVER=ldap://192.168.0.1:389 - URL-ul serviciului Open LDAP (este setat automat la instalare) LDAPZIMBRADN=\"uid=zimbra,cn=admins,cn=zimbra\" - schema LDAP dupa care sunt extrase datele (este setat automat la instalare) LDAPZIMBRAPASS=\"Wy**nfKd\" - parola de access la Open Ldap (este setat automat la instalare) PARALLEL_SUPPORT=0 - suport pentru backup paralel MAX_PARALLEL_PROCESS=3 - numarul de procese paralele In caz ca nu vrem sa indicam username-ul si parola de administrator: # su zimbra # zmprov ca zmbkpose@example.md \"password\" # zmprov ma zmbkpose@example.md zimbraIsAdminAccount TRUE Scriptul executabil se afla in /usr/local/bin/zmbkpose Aditional este propus un script care ofera posibilitatea de a automatiza unele procese. Scriptul de afla in directorul unde a fost dezarhivata arhiva cu instalatia example/usr/local/bin/zmbkpose.wrapper Acest script este copiat in /usr/local/bin/zmbkpose #cd /opt/kit/Zmbkpose-rewrite_proposal_v2.0/ #cp example/usr/local/bin/zmbkpose.wrapper /usr/local/bin/ # chown zimbra:root /usr/local/bin/zmbkpose.wrapper #chmod 700 /usr/local/bin/zmbkpose.wrapper Se instaleaza crontab-ul: # crontab -e Se adauga urmatoarele: ##FULL BACKUPS every day for 400 accounts(-c 400), or for 6 hours(-C 6h) # whichever comes first, only if last full backup has more than 20 days # old(-F 20d). # Pause of 5 seconds between accounts backups( -e 5s) 0 0 * * * su - zimbra -c 'LOG_TYPE=full_bk /usr/local/bin/zmbkpose.wrapper -F 20d -C 6h -c 400 -e 5s' ##INCREMENTAL BACKUPS every day for 3 hours(-C 3h), only if last incremental backup # has more than 30hs old(-I 30h). # Perform a full backup is not has previous incremental (-t) # Pause of 5 seconds betwee accounts backups (-e 5s) 0 6 * * * su - zimbra -c 'LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s' 0 9 * * * su - zimbra -c 'LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s' 0 18 * * * su - zimbra -c 'LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s' 0 21 * * * su - zimbra -c 'LOG_TYPE=inc_bk /usr/local/bin/zmbkpose.wrapper -I 30h -C 3h -t -e 5s' #Remove old backups #Delete cycles off backups older than 15 days(-d 15d). A cycle is a full backups # and its subsequent incremental backups. # zmbkpose will not eliminate backups leaving incomplete cycles 0 2 * * * su - zimbra -c 'LOG_TYPE=del_bk /usr/local/bin/zmbkpose.wrapper -d 15d' #Remove old logs files 0 22 * * * su - zimbra -c 'find /var/log/zmbkpose -type f -mtime +30 -exec rm -f '{}' \\;'","tags":"Zimbra","title":"Zimbra Backup - rezervarea cutiilor postale in Zimbra FOSS"},{"url":"blog/posts/2018/06/21/script-de-modificare-a-fisierelor-in-recursie-pe-foldere/","text":"Intro La inceput voi spune ca acest lucru trivial poate fi facut in diferite moduri, fie prin comenzi direct in consola, fie intr-un manager de fisiere. Insa eu am scris acest script pentru a intari cunostintele in limbajele de sconsola. :) Sarcina Avem doua directorii \"input\" si \"output\". In fiecare din ele se afla fisire , nu are importanta de ce tip si ce contin. Este necesar de a efectua urmatoarele operatii Crearea folderelor in \"output\" dupa cele din \"input\" Efectuarea unei operatii, de ex. modificarea unui cuvint cu sed , in fisierele din \"Input\" si transferarea lor in \"Output\" cu pastrarea denumirii si denumirii folderului. Daca folderul nu exista in \"Output\" , acesta trebuie creat Feetch-uri: 4.1 Raportarea erorilor. 4.2 Numarul fisierelor modificate. 4.3 Timpul de efectuare a ciclului. Scriptul propriu zis Datele de intrare vor fi niste foldere de ex. pe ani. Arata/Ascunde . |-- input | |-- 1991 | | |-- XX-2-145-91.pdf | | |-- XX-2-189-91.pdf | | |-- XX-2-4479-91.pdf | | |-- XX-2-4489-91.pdf | | |-- XX-2-4579-91.pdf | | |-- XX-2-A-2459-91.pdf | | `-- XX-2-A2-459-91.pdf | |-- 1992 | | |-- XX-2-137-92.pdf | | |-- XX-2-336-92.pdf | | |-- XX-2-737-92.pdf | | `-- XX-2-777-92.pdf | |-- 1993 | | |-- XX-2-1654-93.pdf | | |-- XX-2-3424-93.pdf | | |-- XX-2-3644-93.pdf | | |-- XX-2-3654-93.pdf | | `-- XX-2-656-93.pdf | |-- 1994 | | |-- XX-2-211-94.pdf | | |-- XX-2-221-94.pdf | | |-- XX-2-3451-94.pdf | | |-- XX-2-4411-94.pdf | | `-- XX-2-4451-94.pdf | |-- 1995 | | |-- XX-2-3221-95.pdf | | |-- XX-2-3424-95.pdf | | |-- XX-2-3521-95.pdf | | |-- XX-2-3522-95.pdf | | |-- XX-2-3524-95.pdf | | `-- XX-2-3527-95.pdf | |-- 1996 | | |-- XX-1-110-97.pdf | | |-- XX-1-123-97.pdf | | |-- XX-1-143-97.pdf | | `-- XX-1-587-97.pdf | |-- 1997 | | |-- XX-2-22-97.pdf | | |-- XX-2-993-97.pdf | | `-- XX-2-995-97.pdf | |-- 1998 | | |-- XX-2-143-98.pdf | | `-- XX-2-465-98.pdf | `-- 1999 | |-- XX-2-110-99.pdf | |-- XX-2-25-99.pdf | |-- XX-2-3389-99.pdf | `-- XX-2-5555-99.pdf |-- output `-- script.sh Scriptul \"script.sh\" - Acest script va crea doar folderele 1 2 3 4 5 6 7 8 9 #!/bin/bash i_dir = \"input/\" o_dir = \"output/\" i = 0 for dir in ` ls -d $i_dir * ` ; do mkdir $o_dir / ` echo \" $dir \" | awk -F \"/\" '{print $2}' ` ; i = $( expr $i + 1 ) ; done ; echo \"Au fost create \" $i \" foldere\" Dupa executie avem: root@xubuntu:/home/jeka/scripting# ./script.sh Au fost create 9 foldere Rezultat . |-- input | |-- 1991 | | |-- XX-2-145-91.pdf | | |-- XX-2-189-91.pdf | | |-- XX-2-4479-91.pdf | | |-- XX-2-4489-91.pdf | | |-- XX-2-4579-91.pdf | | |-- XX-2-A-2459-91.pdf | | `-- XX-2-A2-459-91.pdf | |-- 1992 | | |-- XX-2-137-92.pdf | | |-- XX-2-336-92.pdf | | |-- XX-2-737-92.pdf | | `-- XX-2-777-92.pdf | |-- 1993 | | |-- XX-2-1654-93.pdf | | |-- XX-2-3424-93.pdf | | |-- XX-2-3644-93.pdf | | |-- XX-2-3654-93.pdf | | `-- XX-2-656-93.pdf | |-- 1994 | | |-- XX-2-211-94.pdf | | |-- XX-2-221-94.pdf | | |-- XX-2-3451-94.pdf | | |-- XX-2-4411-94.pdf | | `-- XX-2-4451-94.pdf | |-- 1995 | | |-- XX-2-3221-95.pdf | | |-- XX-2-3424-95.pdf | | |-- XX-2-3521-95.pdf | | |-- XX-2-3522-95.pdf | | |-- XX-2-3524-95.pdf | | `-- XX-2-3527-95.pdf | |-- 1996 | | |-- XX-1-110-97.pdf | | |-- XX-1-123-97.pdf | | |-- XX-1-143-97.pdf | | `-- XX-1-587-97.pdf | |-- 1997 | | |-- XX-2-22-97.pdf | | |-- XX-2-993-97.pdf | | `-- XX-2-995-97.pdf | |-- 1998 | | |-- XX-2-143-98.pdf | | `-- XX-2-465-98.pdf | `-- 1999 | |-- XX-2-110-99.pdf | |-- XX-2-25-99.pdf | |-- XX-2-3389-99.pdf | `-- XX-2-5555-99.pdf |-- output | |-- 1991 | |-- 1992 | |-- 1993 | |-- 1994 | |-- 1995 | |-- 1996 | |-- 1997 | |-- 1998 | `-- 1999 `-- script.sh Versiunea prefinalaa scriptului Acest script va insera in fiecare fisier \"Sandel scrie in bash\" Acest script este prefinal deoarece acesta insereaza ceva date in fisierele din folderele sursa Scriptul \"script.sh\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash i_dir = \"input/\" #Folderul in care se afla folderele cu fisierele sursa o_dir = \"output/\" #Folderul in care vor fi create folderele cu fisiere d = 0 #Contorul pentru directorii f = 0 #Contorul pentru fisiere for dir in ` ls -d $i_dir * ` ; do #Ciclul pentru foldere mkdir $o_dir / ` echo \" $dir \" | awk -F \"/\" '{print $2}' ` ; for file in ` ls $dir /*.pdf ` ; do #Ciclul pentru fisiere echo \"Sandel scrie in bash\" > $file ; f = $( expr $f + 1 ) ; #Incrementare contor penru fisiere done ; i = $( expr $i + 1 ) ; #Incrementare contor pentru foldere done ; echo \"Au fost create \" $i \" foldere.\" echo \"Au fost modificate \" $f \"fisiere.\" Executam root@xubuntu:/home/jeka/scripting# ./script.sh Au fost create 9 foldere. Au fost modificate 40 fisiere. Versiunea finala a scriptului Acest script va insera in fiecare fisier \"Sandel scrie in bash\" Acest script este prefinal deoarece acesta insereaza ceva date in fisierele din folderele sursa Scriptul \"script.sh\" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash i_dir = \"input/\" #Folderul in care se afla folderele cu fisierele sursa o_dir = \"output/\" #Folderul in care vor fi create folderele cu fisiere d = 0 #Contorul pentru directorii f = 0 #Contorul pentru fisiere for dir in ` ls -d $i_dir * ` ; do #Ciclul pentru foldere mkdir $o_dir / ` echo \" $dir \" | awk -F \"/\" '{print $2}' ` ; for file in ` ls $dir /*.pdf ` ; do #Ciclul pentru fisiere cp $file $o_dir / ` echo \" $dir \" | awk -F \"/\" '{print $2}' ` / #Copie fisierele f = $( expr $f + 1 ) ; #Incrementare contor penru fisiere done ; i = $( expr $i + 1 ) ; #Incrementare contor pentru foldere done ; echo \"Au fost create \" $i \" foldere.\" echo \"Au fost modificate \" $f \"fisiere.\" Rezultat . |-- input | |-- 1991 | | |-- XX-2-145-91.pdf | | |-- XX-2-189-91.pdf | | |-- XX-2-4479-91.pdf | | |-- XX-2-4489-91.pdf | | |-- XX-2-4579-91.pdf | | |-- XX-2-A-2459-91.pdf | | `-- XX-2-A2-459-91.pdf | |-- 1992 | | |-- XX-2-137-92.pdf | | |-- XX-2-336-92.pdf | | |-- XX-2-737-92.pdf | | `-- XX-2-777-92.pdf | |-- 1993 | | |-- XX-2-1654-93.pdf | | |-- XX-2-3424-93.pdf | | |-- XX-2-3644-93.pdf | | |-- XX-2-3654-93.pdf | | `-- XX-2-656-93.pdf | |-- 1994 | | |-- XX-2-211-94.pdf | | |-- XX-2-221-94.pdf | | |-- XX-2-3451-94.pdf | | |-- XX-2-4411-94.pdf | | `-- XX-2-4451-94.pdf | |-- 1995 | | |-- XX-2-3221-95.pdf | | |-- XX-2-3424-95.pdf | | |-- XX-2-3521-95.pdf | | |-- XX-2-3522-95.pdf | | |-- XX-2-3524-95.pdf | | `-- XX-2-3527-95.pdf | |-- 1996 | | |-- XX-1-110-97.pdf | | |-- XX-1-123-97.pdf | | |-- XX-1-143-97.pdf | | `-- XX-1-587-97.pdf | |-- 1997 | | |-- XX-2-22-97.pdf | | |-- XX-2-993-97.pdf | | `-- XX-2-995-97.pdf | |-- 1998 | | |-- XX-2-143-98.pdf | | `-- XX-2-465-98.pdf | `-- 1999 | |-- XX-2-110-99.pdf | |-- XX-2-25-99.pdf | |-- XX-2-3389-99.pdf | `-- XX-2-5555-99.pdf |-- output | |-- 1991 | | |-- XX-2-145-91.pdf | | |-- XX-2-189-91.pdf | | |-- XX-2-4479-91.pdf | | |-- XX-2-4489-91.pdf | | |-- XX-2-4579-91.pdf | | |-- XX-2-A-2459-91.pdf | | `-- XX-2-A2-459-91.pdf | |-- 1992 | | |-- XX-2-137-92.pdf | | |-- XX-2-336-92.pdf | | |-- XX-2-737-92.pdf | | `-- XX-2-777-92.pdf | |-- 1993 | | |-- XX-2-1654-93.pdf | | |-- XX-2-3424-93.pdf | | |-- XX-2-3644-93.pdf | | |-- XX-2-3654-93.pdf | | `-- XX-2-656-93.pdf | |-- 1994 | | |-- XX-2-211-94.pdf | | |-- XX-2-221-94.pdf | | |-- XX-2-3451-94.pdf | | |-- XX-2-4411-94.pdf | | `-- XX-2-4451-94.pdf | |-- 1995 | | |-- XX-2-3221-95.pdf | | |-- XX-2-3424-95.pdf | | |-- XX-2-3521-95.pdf | | |-- XX-2-3522-95.pdf | | |-- XX-2-3524-95.pdf | | `-- XX-2-3527-95.pdf | |-- 1996 | | |-- XX-1-110-97.pdf | | |-- XX-1-123-97.pdf | | |-- XX-1-143-97.pdf | | `-- XX-1-587-97.pdf | |-- 1997 | | |-- XX-2-22-97.pdf | | |-- XX-2-993-97.pdf | | `-- XX-2-995-97.pdf | |-- 1998 | | |-- XX-2-143-98.pdf | | `-- XX-2-465-98.pdf | `-- 1999 | |-- XX-2-110-99.pdf | |-- XX-2-25-99.pdf | |-- XX-2-3389-99.pdf | `-- XX-2-5555-99.pdf `-- script.sh Varianta optimizata Am optimizat scriptul prin includerea unei comenzi ls care arata fisierele sau folderele ls -1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #!/bin/bash i_dir = \"input/\" #Folderul in care se afla folderele cu fisierele sursa o_dir = \"output/\" #Folderul in care vor fi create folderele cu fisiere d = 0 #Contorul pentru directorii f = 0 #Contorul pentru fisiere start = ` date +%s ` for dir in ` ls $i_dir -1 ` ; do #Ciclul pentru foldere mkdir $o_dir / $dir ; for file in ` ls $i_dir / $dir /*.pdf ` ; do #Ciclul pentru fisiere cp $file $o_dir / $dir / #Copie fisierele f = $( expr $f + 1 ) ; #Incrementare contor penru fisiere done ; i = $( expr $i + 1 ) ; #Incrementare contor pentru foldere done ; end = ` date +%s ` runtime = $(( end-start )) echo \"Au fost create \" $i \" foldere.\" echo \"Au fost modificate \" $f \"fisiere.\" echo \"A durat\" $runtime \" sec.\" Recomandari Putem folosi acest ciclu if pentru a verifica daca este deja folderul #-Check dir if [ ! -d \"$DIR\" ];then echo \"Error: Please create directory $DIR, with write permissions for user \\\"$(/bin/id -un)\\\"\" exit 1 fi Surse https://stackoverflow.com/questions/4651437/how-to-set-a-variable-to-the-output-of-a-command-in-bash https://unix.stackexchange.com/questions/52313/how-to-get-execution-time-of-a-script-effectively","tags":"Admin","title":"Script de modificare a fisierelor in recursie pe foldere"},{"url":"blog/posts/2018/06/18/automatizarea-sesiunilor-tmux-cu-tmuxp/","text":"Intro In postul precedent destinat Tmux ne-am familiarizat cu comenzile utile in Tmux; crearea unei sesiuni, divizarea pe ferestre. Cind ne deconectam de la conola procesul Tmux ramine activ si putem reveni la panelurile noastre prin comanda tmux attach . Dar ce facem daca serverul/ PC -ul a fost restartat. Sesiunea Tmux nu mai este. In ajutor ne vine \"tmuxp\", un utilitar foarte comod. Acesta este util ca poate incarca profile deja create , plus executarea comenzilor predefinite la initierea sesiunii Tmux. Mai exista si alte utilitare de acest tip tmuxinator si teamocil Surse Pentru a instala folosim managerul de pachete pip pip install tmuxp Vor vi instalate urmatoarele packete Installing collected packages: PyYAML, kaptan, libtmux, click, colorama, tmuxp Descrierea o gasiti pe Git Lansarea sesiunii Cream un fisier in directorul Home , de ex. mysession.yaml mkdir ~/.muxp/ touch ~/.tmuxp/mysession.yaml nano ~/.tmuxp/mysession.yaml Adaugam urmatorul continut session_name : 4 - pane - split windows : - window_name : dev window layout : tiled shell_command_before : - cd ~/ # run as a first command in all panes panes : - shell_command : # pane no . 1 - cd /var/ log # run multiple commands in this pane - ls - al | grep \\. log - echo second pane # pane no . 2 - echo third pane # pane no . 3 - echo forth pane # pane no . 4 Incarcam profilul tmuxp load ~/.tmuxp/mysession.yaml Sau mai simplu tmuxp load mysession Pentru a simplifica incarcarea profilului adaugam variabila de sistem care va contine directorul spre profilele noastre. export TMUXP_CONFIGDIR=$HOME/.yourconfigdir/tmuxp sau adaugam in ~/.bashrc TMUXP_CONFIGDIR=$HOME/.tmuxpmoo tmuxp load cpython Daca dorim sa incarcam mai multe profile tmuxp load profile1 profile2 Comenzi utile Tmux tmux new-session tmux list-sessions tmux list-windows tmux new-window tmux list-panes tmux split-window tmux send-keys Referinte https://github.com/tmux-python/tmuxp https://tmuxp.git-pull.com/en/latest/quickstart.html","tags":"Admin","title":"Automatizarea sesiunilor Tmux cu Tmuxp"},{"url":"blog/posts/2018/06/18/udpxy-pentru-translarea-rtsp/","text":"","tags":"Raspberry","title":"Udpxy pentru translarea RTSP"},{"url":"blog/posts/2018/06/18/afisarea-variabilelor-in-python/","text":"Intro Afisarea variabilelor este necesara in mare parte pentru a depana vre-o problema oarecare in procesul crearii unui script. Metode de afisare sunt foarte multe care se schimba de la o versiune la alta. Mai jos voi prezenta niste sample-uri. Pass it as a tuple: print(\"Total score for %s is %s\" % (name, score)) A tuple with a single element looks like (â€˜this',).Here are some other common ways of doing it: Pass it as a dictionary: print(\"Total score for %(n)s is %(s)s\" % {'n': name, 's': score}) Use new-style string formatting: print(\"Total score for {} is {}\".format(name, score)) Use new-style string formatting with numbers (useful for reordering or printing the same one multiple times): print(\"Total score for {0} is {1}\".format(name, score)) Use new-style string formatting with explicit names: print(\"Total score for {n} is {s}\".format(n=name, s=score)) Concatenate strings: print(\"Total score for \" + str(name) + \" is \" + str(score)) The clearest two, in my opinion: Just pass the values as parameters: print(\"Total score for\", name, \"is\", score) If you don't want spaces to be inserted automatically by print in the above example, change the sep parameter: print(\"Total score for \", name, \" is \", score, sep='') If you're using Python 2, won't be able to use the last two because print isn't a function in Python 2. You can, however, import this behavior from future : from __future__ import print_function Use the new f-string formatting in Python 3.6: print(f'Total score for {name} is {score}') Exemplu a = 10 b = 20 c = a + b #Normal string concatenation print(\"sum of\", a , \"and\" , b , \"is\" , c) #convert variable into str print(\"sum of \" + str(a) + \" and \" + str(b) + \" is \" + str(c)) # if you want to print in tuple way print(\"Sum of %s and %s is %s: \" %(a,b,c)) #New style string formatting print(\"sum of {0} and {1} is {2}\".format(a,b,c)) #in case you want to use repr() print(\"sum of \" + repr(a) + \" and \" + repr(b) + \" is \" + repr(c)) Surse Stackoverflow","tags":"Python","title":"Afisarea variabilelor in Python"},{"url":"blog/posts/2018/06/15/lucram-cu-functia-random-in-python/","text":"Intro Deseori este necesar de a genera numere sau elemente aliatoate , in acest scop ne ajuta functia Random. Exemple Inseram in scripturi acest cod import random #importam modului random lst = [ 1 , 3 , 10 , 17 ] # Declaram lista de numere `lst` random . shuffle ( lst ) # face permutatii aleatoare in lista `lst` print lst # arata lista `lst` cu permutatie print random . randint ( 1 , 25 ) # Selecteaza un numar aleatoar din secventa 1-25 Alte exemple: >>> random() # Random float: 0.0 <= x < 1.0 0.37444887175646646 >>> uniform(2.5, 10.0) # Random float: 2.5 <= x < 10.0 3.1800146073117523 >>> expovariate(1 / 5) # Interval between arrivals averaging 5 seconds 5.148957571865031 >>> randrange(10) # Integer from 0 to 9 inclusive 7 >>> randrange(0, 101, 2) # Even integer from 0 to 100 inclusive 26 >>> choice(['win', 'lose', 'draw']) # Single random element from a sequence 'draw' >>> deck = 'ace two three four'.split() >>> shuffle(deck) # Shuffle a list >>> deck ['four', 'two', 'ace', 'three'] >>> sample([10, 20, 30, 40, 50], k=4) # Four samples without replacement [40, 10, 50, 30] Functii in modulul Random random.random() - Alege un numar Float (Virgula mobila) in raza (0.0, 1.0). random.shuffle(lista) - Face permutatie intr-o lista random.choice(secventa) - Alege un element aleator dintr-o secventa random.randint() - Alege un numar aleator Integer La crearea scriptului evitati sa denumiti scriptul cu cuvinta; \"rand\" , \"random\" si sa folositi variabile cu numele \"list\" care sunt folosite ca elemente predefinite in acest modul. Aceasta fiind o regula generala in limabjul Python Referinte Python.org","tags":"Python","title":"Lucram cu functia Random in Python"},{"url":"blog/posts/2018/06/13/lucram-cu-browserul-firefox-din-consola-linux/","text":"Intro In proiectele mele de automatizare a aplicatiilor web am necesitatea de a rula script-uri JavaScript direct in browser. Adaugator este necesar de a executa comenzile automat, prin cron. Astfel trebuie sa cunoastem comenzile firefox. In articolele mele din acest blog am aratat cum sa pornim testele Selenium in Selenium Grid. Insa aceste teste sunt scrise in Python si necesita configurarea driver-ului Web (geckodriver). Insa pentru JavaScript nu trebuie sa avem nevoie de soft aditional pentru a le executa, ele trebuie sa fie executate de browser. Deci trebuie sa gasim o comanda care va executa aceste scripturi Comenzi Firefox Am gasit pe net cite-va comenzi Pornirea browserului firefox sau calea completa catre executabil whereis firefox firefox: /usr/bin/firefox /usr/lib/firefox /etc/firefox /usr/share/man/man1/firefox.1.gz /usr/bin/firefox Deschide URL -ul in tab nou /usr/bin/firefox -new-window http://google.com/ Deschide URL -ul in fereastra noua /usr/bin/firefox google.com Lansarea Firefox din consola in DISPLAY -ul necesar si DISPLAY=:0.0 firefox http://google.com Daca dorim lansarea cu un anumit profil (profilele se creaza aparte, si sunt declarate in /home/user/.mozilla/firefox/profiles.ini ) DISPLAY=:0.0 nohup firefox -no-remote -P user1 http://google.com NOHUP se foloseste pentru a rula in background Firefox Cautare /usr/bin/firefox -search \"python\" sau DISPLAY=:0.0 firefox -search \"python\" Preferintele Firefox /usr/bin/firefox -preferences Setare ca browser predefinit /usr/bin/firefox -setDefaultBrowser Executarea scripturilor /usr/bin/firefox \"javascript:alert('Hello World')\" Browser-ele moderne au deja inclus interpretatorul javascript . acesta poate fi chemat: Firefox: CTRL + SHIFT + K - Using the web console . Chrome: CTRL + SHIFT + J - See Developer tools .","tags":"Admin","title":"Lucram cu Browserul Firefox din consola Linux"},{"url":"blog/posts/2018/06/07/lansarea-aplicatiilor-la-distanta-cu-display/","text":"Descrierea problemei Intr-un test Selenium am avut necesitatea de a lansa testul scris in Python din consola. Testul era pentru Selenium care trebuia sa lanseze Browserul si sa execute rutina de comenzi. Insa am primit astfel de eroare ------------------------------------ Captured stderr ------------------------------------ 528354280268 geckodriver INFO Listening on 127.0.0.1:35475 1528354285608 geckodriver::marionette INFO Starting browser /opt/tor-browser/Browser/firefox with args [\"-marionette\"] Error: GDK_BACKEND does not match available displays !!!!!!!!!!!!!!!!!!!!!!!! Interrupted: 1 errors during collection !!!!!!!!!!!!!!!!!!!!!!!! Rezolvarea problemei Am inteles ca in variabiele de sistem nu este definit DYSPLAY . Comanda de mai jos arata ce contine variabila de sistem echo $DISPLAY In consola nu primim nici un raspuns. Insa in sesiunea VNC pe care o am instalata pe serverul de la distanta :1.0 Deci trebuie sa setam variabila de sistem $ DISPLAY . Facem astfel: export DISPLAY=\":1.0\" si apoi rulam scriptul sau aplicatia necesara: pytest script.py sau putem lansa aplicatia in display-ul necesar fara a mofifica variabila de sistem DISPLAY=:1.0 pytest script.py NOTA Fiecare display de pe server are un numar definit. De ex display-ul fizic are variabila $ DISPLAY setata :0.0 Sesiunile VNC se ruleaza pe :1.0 s.a.m.d. Putem afta alstfel ps aux | grep Xorg ps aux | grep vnc Vom primi 957 tty7 Ssl+ 0:22 /usr/lib/xorg/Xorg -core :0 -seat seat0 -auth /var/run/lightdm/root/:0 -nolisten tcp vt7 -novtswitch 3800 pts/6 S+ 0:00 grep --color=auto Xorg ------------------------------- 1084 ? S 0:00 Xvnc4 :1 -desktop xubuntu:1 (user) -auth /home/user/.Xauthority -geometry 1920x1080 -depth 16 -rfbwait 30000 -rfbauth /home/user/.vnc/passwd -rfbport 5901 -pn -fp /usr/X11R6/lib/X11/fonts/Type1/,/usr/X11R6/lib/X11/fonts/Speedo/,/usr/X11R6/lib/X11/fonts/misc/,/usr/X11R6/lib/X11/fonts/75dpi/,/usr/X11R6/lib/X11/fonts/100dpi/,/usr/share/fonts/X11/misc/,/usr/share/fonts/X11/Type1/,/usr/share/fonts/X11/75dpi/,/usr/share/fonts/X11/100dpi/ -co /etc/X11/rgb 1280 ? S 0:00 vncconfig -iconic 3794 pts/6 S+ 0:00 grep --color=auto vnc Mai sus vedem /usr/lib/xorg/Xorg -core :0 si Xvnc4 :1 ceea ce inseamna ca display-ul fizic e pe :0.0 iar vnc pe :1.0 Inca un lucru importatnt este si securitatea de sistem. Aplicatia pate sa nu ruleze in display fara autentificare. Pentru a depasi aceasta in consola de root: xhost +local:root Referinte https://www.raspberrypi.org/forums/viewtopic.php?t=64083 https://kb.iu.edu/d/adhh","tags":"Admin","title":"Lansarea aplicatiilor la distanta cu DISPLAY"},{"url":"blog/posts/2018/06/04/instalarea-unei-versiuni-vechi-firefox-in-linux/","text":"Intro Uneouri dupa instalarea versiunii noi de Firefox nu toate plugin-urile functioneaza , sau aplicatiile web nu mai ruleaza in browser. In acest caz putem downloada arhiva cu bulil-urile mai vechi si instala. Surse Arhiva cu toate versiunile Firefox o putem gasi Arhiva FTP Mozill Aici sunt toate arhitecturile x86 si x64 Instalare Dupa ce ai downloadata versiunea necesara trebuie sa o dezarhivezi, de dorit in /opt tar xvfvj firefox-3.5.9.tar.bz2 -C /opt Daca in sistem este deja o versiune Firefox , e de dorit sa facem o copie de rezerva. Ca deobicei firefox se afla in /usr/bin/firefox cd /usr/bin mv firefox firefox-backup In final facem un link la binar-ul firefox sii ii dam drepturi de executare ln -s /opt/firefox/firefox /usr/bin/firefox chmod 755 /usr/bin/firefox Resurse 1.http://xmodulo.com/how-to-install-old-firefox-on-linux.html","tags":"Admin","title":"Instalarea unei versiuni vechi Firefox in Linux"},{"url":"blog/posts/2018/05/29/teste-de-performanta-cu-selenium-grid/","text":"Intro Selenium Grid este un instrument de testare care ne permite sa executam testele pe diferite masini pe diferite browsere. Este o parte a suitei Selenium care se specializeaza in rularea mai multor teste pe diferite browsere, sisteme de operare si masini. Aveti posibilitatea sa va conectali la acestea cu Selenium Remote specificand browserul, versiunea browserului si sistemul de operare dorit. Tuteti sa va conectati la browser utilizind Selenium Remote. Exista doua elemente principale ale Selenium Grid - un hub si noduri. Ce este un HUB In Selenium Grid, hub-ul este un computer care este punctul central in care ne putem incarca testele. Hubul actioneaza si ca server, deoarece actioneaza ca punct central pentru controlul retelei de masini de testare. Selenium Grid are un singur hub si este comandantul retelei. Atunci cand un test cu anumite capacitati este dat Hubului, Hub-ul cauta nodul care se potriveste cu configuratia data. De exemplu, puteti spune ca doriti sa executati testul pe Windows 10 si pe browserul Chrome cu versiunea XXX . Hub-ul va incerca sa gaseasca o masina in Grid care sa corespunda criteriului si va executa testul pe acea masina. Daca nu exista nici o potrivire, atunci hub-ul returneaza o eroare. Ar trebui sa existe un singur hub intr-o retea. Ce este un NODE In Selenium Grid, un nod este referit la o masina de testare care opteaza sa se conecteze la Hub. Aceasta masina de testare va fi utilizata de Hub pentru a rula testele. O retea Grid poate avea mai multe noduri. Se presupune ca un nod are diferite platforme, adica diferite sisteme de operare si browsere. Nodul nu are nevoie de aceeasii platforma pentru a rula in diferenta de hub-ul. Pregatire Mai intai trebuie sa cream un hub. Apoi, putem conecta (sau \"inregistra\") nodurile la acel hub. Nodurile sunt locul unde se vor desfasura testele noastre, iar hub-ul este responsabil pentru a va asigura ca testele se termina corect (de exemplu, masina cu sistemul de operare si browserul pe care l-am specificat in testul). Aplicatia necesita ca pe masina sa fie instalata JAVA JRE , asa ca asigurati-va ca o aveti instalata. Downloadam packetele necesare Dowload-am Selenium Standalone Server http://selenium-release.storage.googleapis.com/index.html?path=3.12/ . Este o arhiva JAR cd /opt/ wget http://selenium-release.storage.googleapis.com/3.12/selenium-server-standalone-3.12.0.jar Downloadam geckodriver - WebDriver pentru Mozilla Firefox, obiect in codul de automatizare care stie cum sa comunice cu Browserul si Selenium Grid Pe acest link gasiti releas-urle pentru diferite browsere si platforme wget https://github.com/mozilla/geckodriver/releases/geckodriver-v0.20.1-linux32.tar.gz Startare HUB . Startare Selenium HUB pe masina cu OS Debian, sit si Windows este efectuata similar java -jar selenium-server-standalone-<version>.jar -role hub Serverul va starta pe portul 4444 Arata/Ascunde 09:43:04.375 INFO [GridLauncherV3.launch] - Selenium build info: version: â€˜3.12.0', revision: â€˜7c6e0b3' 09:43:04.402 INFO [GridLauncherV3$2.launch] - Launching Selenium Grid hub on port 4444 2018-05-29 09:43:05.980: INFO ::main: Logging initialized @6060ms to org.seleniumhq.jetty9.util.log.StdErrLog 09:43:07.291 INFO [Hub.start] - Selenium Grid hub is up and running 09:43:07.294 INFO [Hub.start] - Nodes should register to http://192.168.88.55:4444/grid/register/ 09:43:07.296 INFO [Hub.start] - Clients should connect to http://192.168.88.55:4444/wd/hub Accesam consola de administrare in browser; http://localhost:4444/grid/console Startare NOD De ex pe masina locala poate fi un NOD . In acest caz startam Nod-ul cu acelasi packet JAR insa cu alte chei java -jar selenium-server-standalone-<version>.jar -role node -hub http://localhost:4444/grid/register DAca avem o masina remore trebuie sa indicam adresa IP a Hub-ului HubIP java -jar selenium-server-standalone-3.3.1.jar -role node -hub http://$HubIP:4444/grid/register -port 4444 sau java -Dwebdriver.gecko.driver=\"C:\\geckodriver.exe\" -jar selenium-server-standalone-3.4.0.jar -role webdriver -hub http://192.168.1.3:4444/grid/register -port 5566 Cream teste Pentru a crea teste trebuie sa alegem limbajul. Pentru Python vom avea nevoie de modului selenium pip install -U selenium ToDO Headless GUI for firefox. â€˜Xvfb is a display server that performs graphical operations in memory' apt-get install xvfb -y Referinte http://toolsqa.com/selenium-webdriver/selenium-grid-how-to-easily-setup-a-hub-and-node/ https://pypi.org/project/selenium/ https://github.com/mozilla/geckodriver/releases https://gist.github.com/curtismcmullan/7be1a8c1c841a9d8db2c","tags":"Admin","title":"Teste de performanta cu Selenium Grid"},{"url":"blog/posts/2018/05/28/dezvoltam-pelican-cream-plugin-uri/","text":"Intro Am ajuns la incercarea de a crea plugin-ul meu propriu pentru a putea integra Elasticsearch, insa fiind la inceput de drum am gasit nu prea multa informatie in Documentatia oficiala Pelican . Am gasit un blog in care este descrisa crearea unui plugin simplu, il voi aplica si il voi modifica dupa necesitate. Haideti sa vedem Crearea plugin-ului Plugin-ul dat va insera in articole butoanele CTRL , ALT prin imagini. In directorul default unde ca deobidei se afla toate plugin-urile ~/pelican-plugins/ cream un director si 2 fisiere: $ cd pelican-plugins/ # Directorul unde se afla plugin-urile $ mkdir keyboard $ cd keyboard $ touch __init__.py kb.py $ ls __init__.py kb.py In scriptul kb.py adaugam urmatorul cod from pelican import signals import logging import re logging . Logger ( __name__ ) def content_object_init ( instance ): \"\"\" Provides the key plugin, make sure that you have Keys.css, http://michaelhue.com/keyscss/ imported inside your HTML. How to use: So you hit CTRL + ALT + DEL when in doubt Note, that light keyboard keys are enabled by default. \"\"\" if instance . _content is not None : # Verificam daca articolul are continut, daca nu acest obiect este ignorat content = instance . _content new_content = re . sub ( r \"\\ (.+?)\\ \" , r '<kbd class=\"light\">\\1</kbd>' , content ) # Inlocuim cu obiectul stilizat prin introducerea tag-ului alt instance . _content = new_content return instance def register (): signals . content_object_init . connect ( content_object_init ) # Inregistram functia in framework-ul Pelican alt ctrl enter tab shift capslock backspace f11","tags":"Pelican","title":"Dezvoltam Pelican - cream plugin-uri"},{"url":"blog/posts/2018/05/28/cautare-in-blog-cu-elasticsearch/","text":"Intro In Pelican exista deja un plugin care are functia de a cauta in blog \"tipue_search\" Vezi pe Git . Acest plugin este bazat pe HTML -ul sitemap.xml (scriptul arata structura site-ului , e un standard care faciliteaza motoarele de cautare) care trebuie generat. Eu vreau sa evit folosirea acestui plugin deoarece vreau sa fac o cautare structurata dupa , tag-uri, cuvinte cheie, categorii, autor , si alte date. Deasemenea vreau sa integrez Elaticsearch cit de mullt e posibil. Pe viitor planific sa integrez si alte date care le voi stoca in ES . Cerinte Pentru a cauta in toate articolele este necesar sa avem instalate modulele python: lxml, requests, bs4, elasticsearch. pip install: lxml, requests, bs4, elasticsearch Modulelel vor permite extragerea informatiilor de pe site si exportarea acestotra intr-un format clar pentru ES Deasemenea vom folosi procedeele descrise in postul Elasticsearch in scripturi Python din acest blog. Scriptul de extragere Pentru a insera datele avem nevoie de un index in ES . Pntru orice eventualitate vom crea un index #sobo in caza ca exista deja il vom elimina: curl -s -XDELETE $es/sobo curl -s -XPUT $es/sobo Scriptul \"grabber.py\" import os , base64 , re , logging , certifi , time , requests from datetime import datetime from bs4 import BeautifulSoup from elasticsearch import Elasticsearch # Log transport details (optional): #logging.basicConfig(level=logging.INFO) # Parse the auth and host from env: bonsai = os . environ [ 'es' ] auth = re . search ( 'https\\:\\/\\/(.*)\\@' , bonsai ) . group ( 1 ) . split ( ':' ) host = bonsai . replace ( 'https:// %s : %s @' % ( auth [ 0 ], auth [ 1 ]), '' ) print host # Connect to cluster over SSL using auth for best security: es_header = [{ 'host' : host , 'port' : 443 , 'use_ssl' : True , 'ca_certs' : certifi . where (), 'http_auth' : ( auth [ 0 ], auth [ 1 ]) }] # Instantiate the new Elasticsearch connection: es = Elasticsearch ( es_header ) #drop_index = es.indices.create(index='sobo', ignore=400) # Elimina indexul #sobo #create_index = es.indices.delete(index='sobo', ignore=[400, 404]) # Creaza indexul #sobo def urlparser ( title , url ): # scrape title p = {} post = title page = requests . get ( post ) . content soup = BeautifulSoup ( page , 'lxml' ) title_name = soup . title . string # scrape tags tag_names = [] desc = soup . findAll ( attrs = { \"property\" : \"article:tag\" }) for x in xrange ( len ( desc )): tag_names . append ( desc [ x - 1 ][ 'content' ] . encode ( 'utf-8' )) # payload for elasticsearch doc = { 'date' : time . strftime ( \"%Y-%m- %d \" ), 'title' : title_name , 'tags' : tag_names , 'url' : url } # ingest payload into elasticsearch res = es . index ( index = \"sobo\" , doc_type = \"docs\" , body = doc ) time . sleep ( 0.5 ) sitemap_feed = 'http://py.din.md/sitemap.xml' page = requests . get ( sitemap_feed ) sitemap_index = BeautifulSoup ( page . content , 'html.parser' ) urls = [ element . text for element in sitemap_index . findAll ( 'loc' )] for x in urls : urlparser ( x , x ) Verificam rezultatele Peentru a verifica ce cite date au fost incluse in ES : curl -s -XGET $es/_cat/indices/sobo?v Show/hide health status index uuid pri rep docs.count docs.deleted store.size pri.store.size green open sobo iKVIQj2XSn6T965mW6SOnA 1 1 21 0 55.9kb 28kb Avem 21 de documente. Putem vedea citeva din ele curl -s -XGET $es/sobo/_search?pretty -d '{\"size\": 3}' Show/hide { \"took\" : 0, \"timed_out\" : false, \"_shards\" : { \"total\" : 1, \"successful\" : 1, \"failed\" : 0 }, \"hits\" : { \"total\" : 21, \"max_score\" : 1.0, \"hits\" : [ { \"_index\" : \"sobo\", \"_type\" : \"docs\", \"_id\" : \"AWOlm6JSpvmi5L9eEGv7\", \"_score\" : 1.0, \"_source\" : { \"date\" : \"2018-05-28\", \"url\" : \"http://py.din.md/blog/posts/2018/05/18/ffmpeg-stream-webcam/\", \"tags\" : [ \"video\", \"bash\", \"ffmpeg\", \"vlc\", \"stream\" ], \"title\" : \"Translarea si inregistrarea web-camerei - SoBo\" } }, { \"_index\" : \"sobo\", \"_type\" : \"docs\", \"_id\" : \"AWOlm6SfKsV6yXB8y2ZY\", \"_score\" : 1.0, \"_source\" : { \"date\" : \"2018-05-28\", \"url\" : \"http://py.din.md/blog/posts/2018/05/18/install-pelican-virtualenv/\", \"tags\" : [ \"python\", \"pelican\" ], \"title\" : \"Istalare Pelican Blog - SoBo\" } }, { \"_index\" : \"sobo\", \"_type\" : \"docs\", \"_id\" : \"AWOlm6lZKsV6yXB8y2ZZ\", \"_score\" : 1.0, \"_source\" : { \"date\" : \"2018-05-28\", \"url\" : \"http://py.din.md/blog/posts/2018/05/18/git-commonly-commands/\", \"tags\" : [ \"bash\", \"github\" ], \"title\" : \"Comenzi utile pentru GitHuB - SoBo\" } } ] } } Intr-un post urmator vom folosi acest script pentru a face \"Cautari\" in blog. Referinte sysadmins.co.za - Partea 1 sysadmins.co.za - Partea 2","tags":"Elastic","title":"Cautare in blog cu Elasticsearch"},{"url":"blog/posts/2018/05/25/inseram-cuprins-ul-in-blogul-pelican/","text":"Inserarea cuprinsului sau ToC. Chiar in aceaesta postare puteti vedea cum arata. :) ToC este un modul in Pelican care poate fi downloadat de pe GitHub https://github.com/ingwinlu/pelican-toc Cerinte ToC necesita inserarea moduluilui Beautifulsoup4 care se instaleaz astfel: pip install beautifulsoup4 Instalam plugin-ul pelican-toc cd pelican-plugins git clone https://github.com/ingwinlu/pelican-toc Modificarea setarilor Pelican In fiserul de configurare pelicanconf.py se adauga acest plugin in sectiunea \" PLUGINS \". se mai adauga citi-va parametri: PLUGINS = ['i18n_subsites', 'tag_cloud', 'related_posts', 'pelican-toc'] TOC = { 'TOC_HEADERS' : '&#94;h[1-6]', # What headers should be included in # the generated toc # Expected format is a regular expression 'TOC_RUN' : 'true', # Default value for toc generation, # if it does not evaluate # to 'true' no toc will be generated 'TOC_INCLUDE_TITLE': 'true', # If 'true' include title in toc } Inserearea in continut. Implicit pe GitHub este oferit urmatorul cod pentru a fi inclus in tema Pelican: {% if article.toc %} <div class= \"col-lg-3 hidden-xs hidden-sm\" > {{ article.toc }} </div> {% endif %} Insa aceasta nu mi-a convenit si am modificat-o putin {% if article.toc %} <div class= \"entry-content\" > <h3> Table of content: </h3> <ul> {{ article.toc }} </ul> </div> {% endif %} Dupa acceasta am adugat acest cod in directorul \"pelican-bootstrap3/templates/includes/toc.html\". Respectiv a fost modificat template-ul \"pelican-bootstrap3/templates/article.html\" incluzind codul {% include 'includes/toc.html' %} <div class= \"entry-content\" > <div class= \"panel\" > <div class= \"panel-body\" > {% include \"includes/article_info.html\" %} </div> </div> {% include 'includes/toc.html' %} {{ article.content }} </div> <!-- /.entry-content --> Note Diferentele dintre pelican-toc si pelican-extract-toc sunt; extract-toc foloseste Markdown (extensie) pentru a genera un ToC si apoi in extrage intr-un mod frumos. Aceasta extensie genereaza ToC automat, eliminand necesitatea de a scrie [ToC] in articolele dvs. Exista, de asemenea, o verificare \"de validitate\" a id-urilor care ar trebui sa fie generate prin markdown.extensions.headerid implicit, dar intr-un fel nu intotdeauna se executa cu success. Referinte https://github.com/ingwinlu/pelican-toc https://github.com/getpelican/pelican-plugins Show/hide Bem - Plecam -","tags":"Pelican","title":"Inseram Cuprins-ul in blogul Pelican"},{"url":"blog/posts/2018/05/25/butonul-showhide-in-blogul-pelican/","text":"Pentru a include acest buton in articole vom avea nevoie de jQuery http://jquery.com/ . Creem un Java Script care il punem in pelican-bootstrap3/static/js/show_hide_toggler.js Includem scriptul Java $(document).ready(function () { $(\"button.toggle-start-hidden\").parent().next().hide(); $(\"button.toggle-start-hidden\").click(function(){ $(this).parent().next().toggle(); }); $(\"button.toggle\").click(function(){ $(this).parent().next().toggle(); }); }); Modificam template-ul Dupa aceasta adaugam in templateul de baza pelican-bootstrap3/templates/base.html (la sfirsitul codului) <!-- Enable show/hide toggler --> <script src= \" {{ SITEURL }} /theme/js/show_hide_toggler.js\" type= \"text/javascript\" ></script> Dupa aceasta putem deja folosi aceast \"feetch\" prin includea textulu dupa declararea butonului. Textul trebuie sa fie separat de un rind !!! <button class= \"toggle-start-hidden\" > Show/hide </button> <button class= \"toggle\" > Show/hide </button> Exemplu Un buton Show/hide Bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla Bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla-bla Alt buton Show/hide Apasa butonul de mai sus pentru a ascunde textul Referinte:","tags":"Pelican","title":"Butonul show/hide in blogul Pelican"},{"url":"blog/posts/2018/05/25/elasticsearch-in-scripturi-python/","text":"Inserarea datelor Sa incepem cu inserarea datelor in indecsii ES care mai apoi vor fi publicate in Blogul Pelican. Cream indexul: curl -s XPUT $es/iptv Datele vor fi inserate din JSON in format primar ( RAW ) Fisierul iptv.json contine datele in urmatorul format (sunt date legate de IPTV ) { \"index\" : { \"_index\" : \"iptv\", \"_type\" : \"channel\", \"_id\" : \"2\" } } { \"title\" : \"MOLDOVA 1\", \"provider\" : \"SCORTEL\", \"imageUrl\" : \"http://fleek.eu.org/logos/MOLDOVA1.png\", \"stream_url_1\" : \"http://88.88.88.88/udp/238.40.9.3:1234\", \"stream_url_2\" : \"http://88.88.88.88/udp/238.40.6.10:1234\", \"stream_url_3\" : \"\" } Pentru a insera datele folosim comanda curl -s -XPUT $es/iptv/_bulk --data-binary @iptv.json Extragerea datelor In continuare trebuie sa plasam datele in blog. Vom folosi clientul oficial Python pentru Elasticsearch Aici poate fi gasita instructiunea http://elasticsearch-py.readthedocs.io/en/master/ Mai intii este nevoie da instala modulul Elasticsearch pentru Python: il vom instala in virtualenv mkvirtualenv elpy workon elpy pip install elasticearch Privim daca sa instalat pip list Obtinem Package Version ------------- ------- elasticsearch 6.2.0 pip 10.0.1 pkg-resources 0.0.0 setuptools 39.2.0 urllib3 1.22 wheel 0.31.1 Vor fi instalate elasticsearch 6.2.0 si urllib3 1.22 Cream un script care va lucra cu documentele din indecsii ES \"elpy.py\" from datetime import datetime from elasticsearch import Elasticsearch es = Elasticsearch () doc = { 'author' : 'JekA' , 'text' : 'Elasticsearch: cool. bonsai cool.' , 'timestamp' : datetime . now (), } res = es . index ( index = \"test-index\" , doc_type = 'tweet' , id = 1 , body = doc ) print ( res [ 'result' ]) res = es . get ( index = \"test-index\" , doc_type = 'tweet' , id = 1 ) print ( res [ '_source' ]) es . indices . refresh ( index = \"test-index\" ) res = es . search ( index = \"test-index\" , body = { \"query\" : { \"match_all\" : {}}}) print ( \"Got %d Hits:\" % res [ 'hits' ][ 'total' ]) for hit in res [ 'hits' ][ 'hits' ]: print ( \" %(timestamp)s %(author)s : %(text)s \" % hit [ \"_source\" ]) Declaratia variabilei es = Elasticsearch() inseamna ca acest script se va conecta la http://localhost:9200 , insa noi vom lucra cu Bonsai.io (Cum am scris in postul precedent , e fara plata si e perfect pentru teste) Bonsai. IO foloseste un astfel de link pentru conexiune https://xxxxxxx_username:xxxxxx+password@user-first-sandbox-349333342.us-west-2.bonsaisearch.net , in acest caz trebuie sa mai setam si module pentru autentificare SSL . Instalam certifi , modul de autentificare in python pip install certifi modificam scriptul elpy.py import os , base64 , re , logging , certifi from datetime import datetime from elasticsearch import Elasticsearch # Logam datele de transport (optional): logging . basicConfig ( level = logging . INFO ) # Extragem datele de autentificare si hostul ES din variabilele env: bonsai = os . environ [ 'es' ] auth = re . search ( 'https\\:\\/\\/(.*)\\@' , bonsai ) . group ( 1 ) . split ( ':' ) host = bonsai . replace ( 'https:// %s : %s @' % ( auth [ 0 ], auth [ 1 ]), '' ) print host # Ne conectam la clusterul ELS prin SSK prin autentificare pentru siguranta: es_header = [{ 'host' : host , 'port' : 443 , 'use_ssl' : True , 'ca_certs' : certifi . where (), 'http_auth' : ( auth [ 0 ], auth [ 1 ]) }] # Initiam o conexiune noua la Elasticsearch es = Elasticsearch ( es_header ) # Verificam daca conexiunea este activa (optional): es . ping () doc = { 'author' : 'Jeka' , 'text' : 'Elasticsearch: cool. bonsai cool.' , 'timestamp' : datetime . now (), } res = es . index ( index = \"test-index\" , doc_type = 'tweet' , id = 1 , body = doc ) print ( res [ 'result' ]) res = es . get ( index = \"test-index\" , doc_type = 'tweet' , id = 1 ) print ( res [ '_source' ]) es . indices . refresh ( index = \"test-index\" ) res = es . search ( index = \"test-index\" , body = { \"query\" : { \"match_all\" : {}}}) print ( \"Got %d Hits:\" % res [ 'hits' ][ 'total' ]) for hit in res [ 'hits' ][ 'hits' ]: print ( \" %(timestamp)s %(author)s : %(text)s \" % hit [ \"_source\" ]) Referinte: http://elasticsearch-py.readthedocs.io/en/master/ http://witkowskibartosz.com/blog/utilizing_elasticsearch_python_client.html#.WwfANyC-mUk https://docs.bonsai.io/docs/python","tags":"Elastic","title":"Elasticsearch in scripturi Python"},{"url":"blog/posts/2018/05/24/lucram-cu-elasticsearch-in-proiecte/","text":"Voi da start unei serii de postari despre Elasicsearch Voi descrie care-va comenzi ES prin care putem opera cu datele Intii de toate avem nevoie de o instanta Elasticsearch , eu am ales siteul bonsai.io, este free si este deajuns pentru testele noastre Pentru a putea mai usor lucra cu comenzile , facem o variabila de sistem es care va inlocui http://localhost:9200 sau alt link de access pa API -ul elasticsearc export es=https://xxxxxxx_username:xxxxxx+password@user-first-sandbox-349333342.us-west-2.bonsaisearch.net 1. Arata versiunea si statutul ES (Elasticsearch) curl -s -XGET $es 2. Arata indecsii din ES curl -s -XGET $es/_cat/indices?pretty sau curl 'localhost:9200/_cat/indices?v' sau cu sortare dupa numarul de documente, descrescator curl -s -XGET $es/_cat/indices?v&s=docs.count:desc Arata o statistica a indexurilor curl -s -XGET $es/_stats/indexing,store?pretty 3. Creaza un index cu numele curl -s XPUT $es/newindex dupa execute {\"acknowledged\":true,\"shards_acknowledged\":true} reprezinta un reziltat pozitiv 4. Stergerea indecsului Pentru a sterge un index din ElasticSearch rulati comanda de mai jos: curl -s -XDELETE $es/newindex 5. Introducerea datelor in Elasicsearch De notat ca sunt doua metode esentiale de adaugare a datelor in Elasticsearch: 1. JSON prin HTTP 2. Clientul native Inserarea unui document in Elasticsearch fara a defini un ID curl -XPUT '$es/data/user/dilbert' -d '{ \"name\" : \"Dilbert Brown\" }' curl -s -XPUT $es/data/post/1 -d ' { \"user\": \"dilbert\", \"postDate\": \"2011-12-15\", \"body\": \"Search is hard. Search should be easy.\" , \"title\": \"On search\" }' curl -s -XPUT $es/data/post/2 -d ' { \"user\": \"dilbert\", \"postDate\": \"2011-12-12\", \"body\": \"Distribution is hard. Distribution should be easy.\" , \"title\": \"On distributed search\" }' curl -XPUT $es/data/post/3 -d ' { \"user\": \"dilbert\", \"postDate\": \"2011-12-10\", \"body\": \"Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat\" , \"title\": \"Lorem ipsum\" }' curl -XPUT $es/data/post/4 -d ' { \"user\": \"Ciobanu\", \"postDate\": \"2018-05-23\", \"body\": \"Cautam in Elasticsearch cu JSON\" , \"title\": \"Cautare din consola\" }' sau intr-o linie curl -s -XPUT '$es/data/user/ciobanu' -d '{ \"name\" : \"Ciobanu\",; \"surname\" : \"Ion\",; \"e-mail\": \"i.ciobanu@domen.md\"}' Sa verificam dacat toate datele au fost inroduse curl -XGET $es/data/user/dilbert?pretty=true curl -XGET $es/data/post/1?pretty=true curl -XGET $es/data/post/2?pretty=true curl -XGET $es/data/post/3?pretty=true 6. Cautare Cautam toate postarile userului Dilbert curl -s -XGET $es/data/post/_search?q=user:dilbert&pretty=true Cautam toate articolele cate nu contin cuvintul \"search\" curl -s -XGET $es/data/post/_search?q=-title:search&pretty=true Cautam toate articolele care contin \"search\" dar nu contin \"disributed\" curl -s -XGET $es/data/post/_search?q=+title:search%20-title:distributed&pretty=true&fields=title' Cautam dupa data curl -s -XGET $es/data/_search?pretty -d '{ \"query\" : { \"range\" : { \"postDate\" : { \"from\" : \"2011-12-10\", \"to\" : \"2011-12-12\" } } } }' Cautam intr-un index curl -s -XGET $es/data/_search?pretty -d '{ \"query\" : { \"match_all\" : {} } }'","tags":"Elastic","title":"Lucram cu Elasticsearch in proiecte"},{"url":"blog/posts/2018/05/24/how-to-transfer-the-spam-db-to-another-server/","text":"How to transfer the anti-spam database to another Zimbra server In this post we will see how the Spamasssain base can be transferred from the old server to a new one. Run this command on the old server su - zimbra /opt/zimbra/libexec/sa-learn -p /opt/zimbra/conf/salocal.cf.in --dbpath /opt/zimbra/data/amavisd/.spamassassin/ --siteconfigpath /opt/zimbra/conf/spamassassin --backup > /tmp/zimbra_q.backup Copy the file /tmp/zimbra_q.backup to the new server Run this command on the new server su - zimbra /opt/zimbra/libexec/sa-learn -p /opt/zimbra/conf/salocal.cf.in --dbpath /opt/zimbra/data/amavisd/.spamassassin/ --siteconfigpath /opt/zimbra/conf/spamassassin --restore /tmp/zimbra_q.backup","tags":"Zimbra","title":"How to transfer the spam db to another server"},{"url":"blog/posts/2018/05/24/iconite-vector-in-blogul-pelican/","text":"Iconite FontAwesome Aceste iconite sunt prezente in orice blog sau site. Sunt de diferite categorii, si reprezinta imagini in miniatura a unor entitati , cum ar fi animale, locuri, cladiri, calculatoare , retele sociale etc. In blogul nostru cu tema pelican-boostrap3 aceste iconite sunt limitate doar la retele sociale , insa si acestea sunt nu prea multe. Am sapat internetul in lung si in lat si am inteles ca toate iconitele sunt deja incluse in tema noastra. Le-am gasit in pelican-bootstrap3/static/css/font-awesome.css . Acestea sunt multe si pot fi idetificate dupa codul Unicode, de exemplu iconita Home codul unicode f015 . Pe toate le gasiti aici https://fontawesome.com/icons?d=gallery Dupa ce am inteles aceasta am cautat template-ul barei din dreapta Sidebar . Configurarea este in pelican-bootstrap3/templates/includes/sidebar/social.html { % if SOCIAL % } { % from 'includes/sidebar/macros.jinja' import title % } < ! -- Sidebar / Social --> < li class = \"list-group-item\" > < h4 > {{ title ( _ ( 'Social' ), DISABLE_SIDEBAR_TITLE_ICONS ) }} </ h4 > < ul class = \"list-group\" id = \"social\" > { % for s in SOCIAL % } { % if s [ 2 ] % } { % set name_sanitized = s [ 2 ] | lower | replace ( '+' , '-plus' ) | replace ( ' ' , '-' ) % } { % else % } { % set name_sanitized = s [ 0 ] | lower | replace ( '+' , '-plus' ) | replace ( ' ' , '-' ) % } { % endif % } *** { % if name_sanitized in [ 'flickr' , 'slideshare' , 'instagram' , 'spotify' , 'stack-overflow' , 'weibo' , 'line-chart' , 'home' , 'user' , 'users' , 'envelope' , 'envelope-o' , 'stack-exchange, ' coffee ', ' laptop ' *** { % set iconattributes = '\"fa fa-' ~ name_sanitized ~ ' fa-lg\"' % } { % else % } { % set iconattributes = '\"fa fa-' ~ name_sanitized ~ '-square fa-lg\"' % } { % endif % } < li class = \"list-group-item\" >< a href = \"{{ s[1] }}\" >< i class = {{ iconattributes }} ></ i > {{ s [ 0 ] }} </ a ></ li > { % endfor % } </ ul > </ li > < ! -- End Sidebar / Social --> { % endif % } Trebuie sa adaugam denumirea iconitei in ciclul if name_sanitized in , de exemplu am daugat ,coffee , laptop Dupa toate acestea este necesar de a include in pelicanconfig.py iconita vector necesara SOCIAL = (('github', 'http://github.com/JacobsCofee'), ('linkedin', 'http://linkedin.com/in/username-82899543'), # ('weibo', 'http://url'), # ('flickr', 'http://url'), # ('slideshare', 'http://url'), # ('instagram', 'http://url'), # ('spotify', 'http://url'), # ('stack-overflow', 'http://url'), # ('line-chart', 'http://url'), # ('user', 'http://url'), # ('users', 'http://url'), ('coffee', 'http://url'), ('laptop', 'http://url'), ('envelope', 'mailto:e-mail@gmail.com'),) # ('envelope-o', 'http://url'), # ('stack-exchange', 'http://url'), # ('hacker-news', 'http://url'), # ('gitlab', 'http://url'), Mai sus sunt comentate iconitee default din tema pelican-bootstrap3 Mai departe trebuie sa vedem cum putem adauga aceste iconite vector in orice pagina a acestui blog. Va urma â€¦","tags":"Pelican","title":"Iconite vector in blogul Pelican"},{"url":"blog/posts/2018/05/24/pelican-related-posts/","text":"Related Posts In acest articol voi descrie modul de adaugare a posturilor relatate unei categorii (Adica posturi propuse spre citire) Pluginul poate fi downloadat de pe GitHub https://github.com/getpelican/pelican-plugins/tree/master/related_posts Ca sa adaugam plugin-ul, trecem in directorul pelican-plugins si copiem cele necesare. git clone https://github.com/getpelican/pelican-plugins/tree/master/related_posts Pentru a adauga pluginul in blog trebuie sa includem in pelicanconfig.py PLUGINS = ['i18n_subsites', 'tag_cloud', 'related_posts'] Setarile plugin-lui sunt: RELATED_POSTS_MAX = 10 RELATED_POSTS_SKIP_SAME_CATEGORY = True Prima directiva RELATED_POSTS_MAX = 10 indica ca sa fie aratate nu mai mult de 10 postari. A doua directiva RELATED_POSTS_SKIP_SAME_CATEGORY = True indica ca sa nu fie aratate postari din aceeasi categorie cind vedem un post. Deasemenea putem sa includem Related Posts in orice template cu acest cod: {% if article.related_posts %} <ul> {% for related_post in article.related_posts %} <li><a href= \" {{ SITEURL }} / {{ related_post.url }} \" > {{ related_post.title }} </a></li> {% endfor %} </ul> {% endif %} Posturile relatate au un tag related_posts: care poate fi inclus in orice postare related_posts : slug1 , slug2 , slug3 , ... slugN voila!","tags":"pelican","title":"Adaugare plugin Related Posts"},{"url":"blog/posts/2018/05/22/add-calendar-to-all-zimbra-users/","text":"Sarcina pusa este: Crarea unui calendar comun pentru toti utilizatorii cu urmatoarele proprietati: Calendarul trebuie sa fie inclus in toate conturile participantilor Va fi completat de fiecare participant in conformitate cu programul zilei propriu. Participantii pot vedea statutul celulilalt paricipant (Ocupar/Disponibil) in calendarul sau. Participantii vor fi adaugati automat la crearea unui nou utilizator Un cont specializat va integra toate calendarele pentru a crea reguli VOIP de readresare a apelurilor Crearea unui calendar comun cu zilelel de odihna si sarbatori. Calendarul trebuie sa fie public. Va fi administrat doar de o persoana 1. Crarea unui calendar comun pentru toti utilizatorii Se creaza un Operator de calendar, de ex. robocall@domen.md Se creaza un un grup de distibutie cu toti paricipantii, de ex. call.center@domen.md In acest grup se adauga toti participantii care vor partaja calendarele proprii Se executa comanda zmprov pentru a aadauga calendele din grupul call.center@domen.md : zmmailbox -z -m robocall@domen.md modifyFolderGrant /Calendar group call.center@domen.md r Se adauga calendarele partajate ale participantilor grupului zmmailbox -z -m robocall@domen.md createMountpoint --view appointment \"/OP1\" operator1@domen.md /Calendar zmmailbox -z -m robocall@domen.md createMountpoint --view appointment \"/OP2\" operator2@domen.md /Calendar zmmailbox -z -m robocall@domen.md createMountpoint --view appointment \"/OP3\" operator3@domen.md /Calendar Adaugarea calendarului in contul de integrare prin Export/Import Salvam calendarul necesar wget --user operator1@domen.md --password password --no-check-certificate https://hostname/home/operator1@domen.md/Calendar.ics Importam in calendarul contului specilaizat curl --insecure -u robcall@domen.md:password --upload-file Calendar.ics https://hostname/service/home/robocall@domen.md/Calendar?fmt=ics 2. Adaugarea mai multor calendare ale utilizatorilor intr-un calendar specializat. Creem calendarul zmprov sm operator2@domen.md createFolder --view appointment --color blue --flags \"#\" /RoboCal Setam permisiuni de citire pentru calendareele create pentru utilizatorii; operatpr1, operator2, operator3 zmmailbox -z -m operator1@domen.md modifyFolderGrant /RoboCal group call.center@domen.md r zmmailbox -z -m operator2@domen.md modifyFolderGrant /RoboCal group call.center@domen.md r zmmailbox -z -m operator3@domen.md modifyFolderGrant /RoboCal group call.center@domen.md r Se include fiecare calendar in contul specializat zmmailbox -z -m robocall@domen.md createMountpoint --view appointment -color blue --flags \"#\" \"/Operator1\" operator1@domen.md /RoboCal zmmailbox -z -m robocall@domen.md createMountpoint --view appointment -color blue --flags \"#\" \"/Operator2\" operator2@domen.md /RoboCal zmmailbox -z -m robocall@domen.md createMountpoint --view appointment -color blue --flags \"#\" \"/Operator3\" operator3@domen.md /RoboCal --flags \"#\" semnifica ca calendarul este bifat Pentru a automatiza procesul vom folosi un script bash: https://wiki.zimbra.com/wiki/Automating_Reciprocal_Calendar_Sharing 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #!/bin/bash if [ \" $# \" == \"1\" ] then users = $( zmsoap --type admin --zadmin GetDistributionListRequest/dl = \" $1 \" @by = \"name\" | grep dlm | sed -e 's/.*<dlm>\\(.*\\)<\\/dlm>/\\1/g' ) echo $users for u in $users do echo zmmailbox -z -m $u modifyFolderGrant /RoboCal group call.center@domen.md r uname = $( zmmailbox -z -m $u gid -v | grep zimbraPrefFromDisplay | sed -e 's/.*: \"\\(.*\\)\",/\\1/' ) for v in $users do if [ $u ! = $v ] then echo zmmailbox -z -m $v createMountpoint --view appointment \\\" / $uname \\' s Calendar \\\" $u /RoboCal fi done done else echo \"usage: $0 distlist@zimbradomain.com\" fi Salvam scriptul ca zimbraRecipCalShare.sh . Dam drepturi de executie chmod +x zimbraRecipCalShare.sh Rulam scriptul de sub utilizatorul zimbra (parametrul liniei este grupul in care sunt adaugati toti participantii) zimbraRecipCalShare.sh call.center@domen.md > check_me_first.sh Verifica daca continutul scriptului contine comenzi zmmailbox corecte si executam rezultatul bash check_me_first.sh In rezultat fiecare din participanti va avea calendarele celorlalti cu drepturi doar de citire.","tags":"Zimbra","title":"Add calendar to all Zimbra users"},{"url":"blog/posts/2018/05/20/tmux-screen-manager/","text":"Instalarea tmux In Debian apt-get install tmux In Centos yum install tmux Startare tmux si lucrul cu ecranele Tmux se starteaza prin comanda: tmux Pentru a deschide ecrane noi in tmux folositi combinatia de taste CTRL + b si apoi separat % . Pentru a tranzita intre ferestre folositi combinatiile de taste CTRL + b urmat de o sau CTRL + b urmat de > , < , &#94; , v . Pentru a inchide un ecran inchideti shell-ul folosind CTRL + d sau exit sau logout . Pentru a va detasa de tmux folositi combinatia de taste ctrl + b urmat de d . Pentru a va reatasa la tmux folositi comanda tmux attach Alte comenzi: Inchide panelul curent: CTRL - b + x Adauga un panel in fereastra curenta (pe oriozontala): CTRL - b + SHIFT - \" Interschima continutul intre peneluri: CTRL - b + SHIFT - [ si CTRL - b + SHIFT - ] Listeaza sesiunile tmux: CTRL - b + w Arata numarul panelulului: CTRL - b + q Trece la urmatoarea sesiune tmux: CTRL - b + n Trece la sesiune tmux precedenta: CTRL - b + p Arata toate comenzile posibile: tmux list-keys Referinte https://gist.github.com/karenyyng/5de2823651965361b788","tags":"Admin","title":"Lucram cu tmux"},{"url":"blog/posts/2018/05/18/ffmpeg-stream-webcam/","text":"In acest post am pus citeva comenzi utile pentru organizarea translarii camerei web cu FFmpeg si VLC Startarea translarii cu vlc /usr/bin/vlc-wrapper v4l2:///dev/video0 :v4l2-standard= :input-slave=alsa://hw:0,0 :live-caching=300 :sout=\"#transcode{vcodec=WMV2,vb=800,scale=1,acodec=wma2,ab=128,channels=2,samplerate=44100}:http{dst=:8080/stream.wmv}\" Translarea in webm (Video si Sunet) ffmpeg -s 640x360 \\ -f video4linux2 -i /dev/video0 -isync -vcodec libvpx -vb 768000 -r 10 -vsync 1 \\ -f alsa -ac 1 -i hw:1,0 -acodec libvorbis -ab 32000 -ar 11025 \\ -f webm /var/www/test.webm Translarea in webm (Video) ffmpeg -s 640x360 \\ -f video4linux2 -i /dev/video0 -isync -vcodec libvpx -vb 768000 -r 10 -vsync 1 \\ -f webm /var/www/telemed/test.webm ffmpeg -s 640x360 -f video4linux2 -i /dev/video0 -isync -vcodec libvpx -vb 768000 -r 10 -vsync 1 -f webm /mnt/ntfs/allusers/Cam/`date +%F-%H-%M-%S`.webm Inregistrare Stream ffmpeg -i http://88.88.88.88/udp/238.40.9.29:1234 -r 15 /tmp/publika.mp4","tags":"Admin","title":"Translarea si inregistrarea web-camerei"},{"url":"blog/posts/2018/05/18/install-pelican-virtualenv/","text":"Intii de tote avem nevie ca in sistem sa fie instalat Python 2.7 si Pip (Python Package Manager) apt-get install python python-virtualenv python-pip verificam daca PIP este instalat command -v pip Virtualenv Virtualenv este un mediu virtual destinat pentru pastrarea dependentelor prin crearea de medii virtuale Python. De exemplu \"Proiectul X depinde de versiunea 1.x dar, proiectul Y are nevoie de 4.x\" Virtualenv pastreaza directorul global de pachete curat si usor de gestionat. Se instaleaza Virtualenv si Virtualenvwrapper pip install virtualenv virtualenvwrapper In ~/.bashrc scriem: export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python source /usr/local/bin/virtualenvwrapper.sh Se executa source ~/.bashrc La acest moment puteam crea medii virtuale, fara a incarca sistemul cu pachete Creare VENV mkvirtualenv nume-venv Lucram in VENV workon nume-venv Listare VENV lsvirtyualenv Parasim VENV deactivate Eliminate VENV rmvirtualenv Cupa ce mediul virtual a fost creat , intram in acesta cu comanda workon name-venv si instalam packetele necesare cu PIP mkvirtualenv pelican mkdir pelican cd pelican pip install pelican markdown Pentru a instala packetele necesare unui proiect putem folosi fisierul requiremenst.txt si comanda install -r requirements.txt Pntru a initia blogul vedeti postul http://py.din.md/blog/posts/2018/05/17/create-pelican-blog/ Sursa: http://nosferalatu.com/setting-up.html","tags":"Pelican","title":"Istalare Pelican Blog"},{"url":"blog/posts/2018/05/18/modify-theme-bootstrap/","text":"Mai intii haideti sa vedem ce modificari sunt propuse. Pe acest liunk sunt aratate Demo pentru diferite stiluri de vizualizare https://www.bootstrapcdn.com/bootswatch/ Eu am ales bootstrap.slate.min.css . Ca sa aplicam CSS -ul trebuie sa il copiem in directorul temei \"pelican-bootstrap3\" cd pelican-themes/pelican-bootstrap3/static/css Facem o copie de rezerva cp -Ra bootstrap.min.css bootstrap.min.css.bk Copiem CSS -ul din directorul repectiv (poate fi downloadat direct de pe https://www.bootstrapcdn.com/bootswatch/ ) cp bootstrap.slate.min.css bootstrap.min.css","tags":"Pelican","title":"Modificarea temei - Pelican"},{"url":"blog/posts/2018/05/18/git-commonly-commands/","text":"Git Commands A list of my commonly used Git commands Getting & Creating Projects Command Description git init Initialize a local Git repository git clone ssh://git@github.com/[username]/[repository-name].git Create a local copy of a remote repository Basic Snapshotting Command Description git status Check status git add [file-name.txt] Add a file to the staging area git add -A Add all new and changed files to the staging area git commit -m \"[commit message]\" Commit changes git rm -r [file-name.txt] Remove a file (or folder) Branching & Merging Command Description git branch List branches (the asterisk denotes the current branch) git branch -a List all branches (local and remote) git branch [branch name] Create a new branch git branch -d [branch name] Delete a branch git push origin --delete [branchName] Delete a remote branch git checkout -b [branch name] Create a new branch and switch to it git checkout -b [branch name] origin/[branch name] Clone a remote branch and switch to it git checkout [branch name] Switch to a branch git checkout - Switch to the branch last checked out git checkout -- [file-name.txt] Discard changes to a file git merge [branch name] Merge a branch into the active branch git merge [source branch] [target branch] Merge a branch into a target branch git stash Stash changes in a dirty working directory git stash clear Remove all stashed entries Sharing & Updating Projects Command Description git push origin [branch name] Push a branch to your remote repository git push -u origin [branch name] Push changes to remote repository (and remember the branch) git push Push changes to remote repository (remembered branch) git push origin --delete [branch name] Delete a remote branch git pull Update local repository to the newest commit git pull origin [branch name] Pull changes from remote repository git remote add origin ssh://git@github.com/[username]/[repository-name].git Add a remote repository git remote set-url origin ssh://git@github.com/[username]/[repository-name].git Set a repository's origin branch to SSH Inspection & Comparison Command Description git log View changes git log --summary View changes (detailed) git diff [source branch] [target branch} Preview changes before merging Source https://github.com/joshnh/Git-Commands/blob/master/ README .md Initierea locala a proiectului git init git add README.md git commit -m \"Primul commit\" git remote add origin https://github.com/JacobsCofee/sobo.git git pull git push -u origin master Facem Update la repozitoru local git pull origin master sau git pull origin new-branch Se reseteaza si se actuliazeaza git reset --hard HEAD git fetch origin git reset --hard origin/master Se face copie de rezerva in alt Branch git commit -a -m \"Saving my work, just in case\" git branch my-saved-work Se sterg fisierele locale git clean -f Se reseteaza Credentialele git config --global user.name \"Your Name\" git config --global user.email you@example.com","tags":"Github","title":"Comenzi utile pentru GitHuB"},{"url":"blog/posts/2018/05/17/pelican-markdown/","text":"Eu deseori cind scriu continutul uit cum sa fac ca textul sa fie Bold/Italic sau sa inserez un link , este diferit de HTML . Mai jos voi da exemple cum putem structura textul. Antet (H1, H2, â€¦ H6); # Antet H1 ## Antet H2 ... ###### Antet H6 Exemplu Exemplu Exemplu Exemplu Exemplu Exemplu Exemplu Header This is a huge header ================== this is a smaller header ------------------ Exemplu This is a huge header this is a smaller header Caractere Bold\\Cursiv\\Italic *this is in italic* and _so is this_ **this is in bold** and __so is this__ ***this is bold and italic*** and ___so is this___``` Exemplu this is in italic and so is this this is in bold and so is this this is bold and italic and so is this Linie orizontala _ _ _ _ * * * * - - - - Exemplu sau sau Citate > De ce nu > Ar putea fi Exemplu De ce nu Ar putea fi Liste * Primul item * Al doilea item * Al treilea item Exemplu Primul item Al doilea item Al treilea item sau enumerare 1. Primul item + Al doilea item * Al treilea item sau 1. Primul item + Al doilea item * Al treilea item 9. orice numar de caractere , +, -, sau * va continua lista. * include 4 spatii (sau Tab) pentru a continua cu sublista 1. ontunam listarea entitatilor * am revenit la nivelul 2 Exemplu Primul item Al doilea item Al treilea item orice numar de caractere , +, -, sau * va continua lista. include 4 spatii (sau Tab) pentru a continua cu sublista ontunam listarea entitatilor am revenit la nivelul 2 Cod sursa Codul sursa se include in \" \"la inceput si la sfirsit Astfel se include o parte a unui cod sursa cod susrsa` in text Link-uri < http : //someurl> < somebbob @ example . com > [ like this ]( http : //someurl) [ like this ]( http : //someurl \"this title shows up when you hover\") Exemplu http://someurl somebob@example.com like this like this Link-uri cu referinte You can also put the [ link URL ][ 1 ] below the current paragraph like [ this ][ 2 ]. [ 1 ] : http : //url [ 2 ] : http : //another.url \"A funky title\" Output: You can also put the link URL below the current paragraph like this . Imagini Imagine ! [ alt text ] ( http : //config.eu.org/wp-content/uploads/2015/06/linux_console_Services_Featured.jpg) ![alt text] (http://config.eu.org/wp-content/uploads/2015/06/linux_console_Services_Featured.jpg) Lista TO - DO - [ ] Nu este executat - [x] Executat - [ ] Nu a fost indeplinit Exemplu: [ ] Nu este executat [x] Executat - [ ] Nu a fost indeplinit Tabele Coloana 1 | Coloana 2 ----------|---------- Item 1.1 | Item 2.1 Item 1.2 | Item 2.2 Output: Coloana 1 Coloana 2 Item 1.1 Item 2.1 Item 1.2 Item 2.2 Output 2: First Header Second Header Content Cell Content Cell Content Cell Content Cell Tabelul poate fi aranjat - stinga, centru, dreapta Coloana 1 | Coloana 2 | Coloana 3 :- -------- |:- --------: | ----------: | Stinga | Centru | Dreapta Output: Coloana 1 Coloana 2 Coloana 3 Stinga Centru Emoji Markdown poate interpreta si Emoji, sunt vizibile si n GitHUB :smile: :cry: :wink: :sleeping: :angry: :smoke: Cod HTML Deasemenea poate fi inclus cod HTML pentru a putea insera Video de pe YouTube, slide-uri etc < img style = \"float: right;\" src = \"/static/about.jpg\" alt = \"Photo\" /> Referinte https://sourceforge.net/p/pelican-edt/wiki/markdown_syntax/ https://eax.me/pelican/ Un test","tags":"Pelican","title":"Adaugarea continutului si formatarea"},{"url":"blog/posts/2018/05/17/create-pelican-blog/","text":"Pelican este gratuit/open source. Facilitatile care permit o utilizare usoara sunt: postarile si paginile sunt scrise cu marcaje. Pelican este unul dintre cele mai populare generatoare de site-uri disponibile. Este scris in Python si vine cu o multime de plugin-uri pentru a extinde functionalitatea. Pelican este gratuit/open source. Facilitatile care permit o utilizare usoara sunt: postarile si paginile sunt scrise cu marcaje. Fragmente html personalizate pot fi, de asemenea, utilizate. O colectie vasta de teme si plugin-uri disponibile. scrieti propria tema si pluginuri cu usurinta. Rezultatul complet static, poate gazdui oriunde. Aici sunt instructiunile de instalare a pachetului PELICAN http://docs.getpelican.com/en/3.6.3/install.html Vom trece la initializarea proiectului pelican-quickstart Vom introduce datele despre blogului Welcome to pelican-quickstart v3.7.1. This script will help you create a new Pelican-based website. Please answer the following questions so this script can generate the files needed by Pelican. > Where do you want to create your new web site? [.] > What will be the title of this web site? sobo > Who will be the author of this web site? JekA > What will be the default language of this web site? [en] > Do you want to specify a URL prefix? e.g., http://example.com (Y/n) > What is your URL prefix? (see above example; no trailing slash) py.din.md > Do you want to enable article pagination? (Y/n) > How many articles per page do you want? [10] > What is your time zone? [Europe/Paris] > Do you want to generate a Fabfile/Makefile to automate generation and publishing? (Y/n) > Do you want an auto-reload & simpleHTTP script to assist with theme and site development? (Y/n) > Do you want to upload your website using FTP? (y/N) > Do you want to upload your website using SSH? (y/N) > Do you want to upload your website using Dropbox? (y/N) > Do you want to upload your website using S3? (y/N) > Do you want to upload your website using Rackspace Cloud Files? (y/N) > Do you want to upload your website using GitHub Pages? (y/N) Done. Your new project is available at /home/beugen83/sobo Proiectul va consta in urmatoarea ierarhie (cu exceptia paginilor - prezentate in paranteze de mai jos - pe care le puteti adauga optional daca intentionati sa creati continut non-cronologic): yourproject/ +-- content L-- (pages) +-- output +-- develop_server.sh +-- fabfile.py +-- Makefile +-- pelicanconf.py # Main settings file L-- publishconf.py # Settings to use when ready to publish In continuare vom adauga prima pagina Trecem in directorul content/ si ream un fisier , de ex 2018-05-17-primul-post.md cd content/ nano 2018-05-17-primul-post.md Introducem textul Title : Primul post - Pelican Date : 2018 - 05 - 17 10 : 20 Modified : 2010 - 05 - 17 10 : 31 Category : Python Tags : pelican , sample Slug : primul - post Authors : JekA , Summary : Acesta este primul post in blogul meu , in acest sumar se scrie textul care va aparea pe prima pagina inainte de a vedea restul ( more ...) ### Pelican is a static site generator , written in Python . Highlights include : Write your content directly with your editor of choice in reStructuredText or Markdown formats Includes a simple CLI tool to ( re ) generate your site Easy to interface with distributed version control systems and web hooks Completely static output is easy to host anywhere Ready to get started ? Check out the Quickstart guide . Pelican is a static site generator , written in Python . Highlights include : ### Pelican 3 currently supports : Articles ( e . g ., blog posts ) and pages Comments , via an external service ( Disqus ). If you prefer to have more control over your comment data , self - hosted comments are another option . Check out the Pelican Plugins repository for more details . Theming support ( themes are created using Jinja2 templates ) Publication of articles in multiple languages Atom / RSS feeds Code syntax highlighting Import from WordPress , Dotclear , or RSS feeds Integration with external tools : Twitter , Google Analytics , etc . ( optional ) Fast rebuild times thanks to content caching and selective output writing Se trece in directorul de baza cd ../ Se efectuiaza comanda de generare a continutului static pelican content Obtinem Done : Processed 1 article , 0 drafts , 0 pages and 0 hidden pages in 0.13 seconds . Generarea continutului poate fi efectuata prin comanda make html Startam serverul make serve sau ./develop_server.sh start sau cd output python -m pelican.server Oprim serviciul prin CTRL-C sau ./develop_server.sh stop Dupa startarea serviciului blogul este accesibil la adresa http://127.0.0.1:8000 Editarea live: In one shell, run make regenerate . This automatically regenerates the site directory whenever you change a file in the source directory. In another shell, run the local web server make serve . Now you can change any file, refresh your browser, and immediately see your changes. The command make devserver will also do that, but it calls a Bash script, which doesn't work on Windows. Sursa: http://nosferalatu.com/setting-up.html","tags":"Pelican","title":"Crearea blogului in Pelican"},{"url":"blog/posts/2018/05/17/pelican-themes-plugins/","text":"Teme Pe site-ul proiectului Pelican https://github.com/getpelican sunt un numar mare de teme care pot fi adapattet la blogul nostru. Aici puteti sa le vedeti cum arata http://www.pelicanthemes.com . Eu mi-am facut alegerea in \"pelican-bootstrap3\". Pentru a adauga tema copiem directorul respectiv in radacina site-ului cd /tmp/ git clone --recursive https://github.com/getpelican/pelican-themes ~/pelican-themes Comanda de mai sus va copia toate temele, insa noi avem nevoie doar de cea aleasa. mkdir pelican-themes cp -Ra /tmp/pelican-themes_bk/pelican-bootstrap3/ ./pelican-themes/ Fiecare tema are unele setari care le diferentiaza. De exemplu \"pelican-bootstrap3\" poate fi fosita in mai multe limbi. Astfel este necesar de a citi README .md pentru fiecare pentru a vedea de ce este necesar pentru a fi compatibila cu blogul tau. Pentru a aplica tema in blog este necesar in fisierul de configurare \"pelicanconf.py\" de inclus THEME = \"pelican-themes/pelican-bootstrap3\" Am nevoie de a include in fisierul de configurare si environment Jinja2 JINJA_ENVIRONMENT = {'extensions': ['jinja2.ext.i18n']} Deasemenea tema necesita plugin-ul \"i18n_subsites\" Plugin-uri Pentru a instala plugin-urile necesare se procedeaza la fel ca si cu temele cd /tmp/ git clone --recursive https://github.com/getpelican/pelican-plugins ~/pelican-plugins Se copie in directorul de baza mkdir pelican-plugins cp -Ra /tmp/pelican-plugins/i18n_subsites/ ./pelican-plugins/ Se activeaza plugin-ul in \"pelicanconf.py\" PLUGIN_PATHS = ['pelican-plugins'] PLUGINS = ['i18n_subsites'] Daa folosim limba Ungleza in blogul nostru includem I18N_TEMPLATES_LANG = 'en' Salvam si startam serverul Alte customizari Pe pagina temei https://github.com/getpelican/pelican-themes/tree/master/pelican-bootstrap3 sunt descrise mai multe optiuni ale temei \"Pagination, Breadcrumbs, Navbar, Related Posts, Series, Favicon, Tag Cloud, etc.\" Adaugarea tag-urilor in sidebar (Aici e descris cum se instaleaza plugin-ul https://github.com/getpelican/pelican-plugins/tree/master/tag_cloud ) In \"pelivcanconf.py\" PLUGIN_PATHS = ['pelican-plugins','tac_cloud'] apoi se adauga DISPLAY_TAGS_ON_SIDEBAR = True DISPLAY_TAGS_INLINE = True Posturi recente in sidebar DISPLAY_RECENT_POSTS_ON_SIDEBAR = True categoriile in sidebar DISPLAY_CATEGORIES_ON_SIDEBAR = True Linkuri sociale SOCIAL = (('twitter', 'http://twitter.com/DaanDebie'), ('linkedin', 'http://www.linkedin.com/in/danieldebie'), ('github', 'http://github.com/DandyDev'), ('stackoverflow', 'http://stackoverflow.com/users/872397/dandydev', 'stack-overflow')","tags":"Pelican","title":"Customizarea blogului PELICAN"},{"url":"blog/posts/2018/05/17/zimbra-bash-change-status-of-account/","text":"Am gasit pe internet urmatorea comanda pentru a modifica recursiv toate conturile din statut \"Activ\" in statut \"Closed\". Deasemenea poate fi utilizat pentru alte operatiuni cu conturile Zimbra Folosim urmatorul script in bash for i in `zmprov -l gaa bd.xenos`; do zmprov ma $i zimbraAccountStatus closed; done","tags":"Zimbra","title":"Modifica conturile  din statutul \"Active\"  in \"Closed\""},{"url":"blog/posts/2018/05/17/primul-post/","text":"Pelican is a static site generator, written in Python. Highlights include: Write your content directly with your editor of choice in reStructuredText or Markdown formats Includes a simple CLI tool to (re)generate your site Easy to interface with distributed version control systems and web hooks Completely static output is easy to host anywhere Ready to get started? Check out the Quickstart guide.Pelican is a static site generator, written in Python. Highlights include: Pelican 3 currently supports: Articles (e.g., blog posts) and pages Comments, via an external service (Disqus). If you prefer to have more control over your comment data, self-hosted comments are another option. Check out the Pelican Plugins repository for more details. Theming support (themes are created using Jinja2 templates) Publication of articles in multiple languages Atom/ RSS feeds Code syntax highlighting Import from WordPress, Dotclear, or RSS feeds Integration with external tools: Twitter, Google Analytics, etc. (optional) Fast rebuild times thanks to content caching and selective output writing","tags":"Pelican","title":"Primul post - Pelican"},{"url":"blog/posts/2018/05/16/use-github/","text":"Aici voi descrie cum se poate de plasat blogul Pelican pe GitHUB In primu rind cream un director unde vom avea site-ul nostru mkdir sobo Trecem in director cd sobo Initiam GIT git init Cream u fisier README .md in care scriem denumirea proiectului, destinatia acestuia etc. nano README.md << Primul proiect , bla, bla, bla Dam o descriere a modificarilor efectuate (Modificarile trebuie sa fie originale, deoarece aceali comentariu nu permite actualizarea) git commit -m \"Primul commit\" Indicam repozitorul unde va fi plasat continutul (Acest repozitor trebuie sa fie deja creat in GitHUB) git remote add origin https://github.com/JacobsCofee/sobo.git Transferam continutul (Vor fi necesare Username si Pass de la GitHUB) git push -u origin master Daca da eroare To https://github.com/JacobsCofee/sobo.git ! [rejected] master -> master (non-fast-forward) error: failed to push some refs to 'https://github.com/JacobsCofee/sobo.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. Efectuam git pull Fortam transferarea continutului (Vor fi necesare Username si Pass de la GitHUB) git push -f origin master","tags":"GitHUB","title":"Initierea proiectelor pe GitHUB"},{"url":"blog/posts/2017/05/17/test-typography-table/","text":"Toata informatia o puteti gasi aici https://bootswatch.com/darkly/ Navbar Navbar Home (current) Features Pricing About Search Buttons Primary Secondary Success Info Warning Danger Link Block level button Tables Type Column heading Column heading Column heading Active Column content Column content Column content Default Column content Column content Column content Primary Column content Column content Column content Secondary Column content Column content Column content Success Column content Column content Column content Danger Column content Column content Column content Warning Column content Column content Column content Info Column content Column content Column content Light Column content Column content Column content Dark Column content Column content Column content Progress","tags":"Pelican","title":"Typography pentru Pelican"},{"url":"blog/posts/2017/05/17/fsck-bad-blocks-mark/","text":"Check and mark badblocks on ext4 partitions command: fsck.ext4 -vcDfty -C 0 /dev/vg0/lv0 And the result was: /dev/vg0/lv0: ***** FILE SYSTEM WAS MODIFIED ***** 6329 inodes used (0.01%, out of 107380736) 44 non-contiguous files (0.7%) 4 non-contiguous directories (0.1%) # of inodes with ind/dind/tind blocks: 0/0/0 Extent depth histogram: 6123/119 86511679 blocks used (20.14%, out of 429497344) 178 bad blocks 40 large files 5522 regular files 719 directories 0 character device files 0 block device files 0 fifos 4294967278 links 0 symbolic links (0 fast symbolic links) 0 sockets ------------ 5965 files Memory used: 676k/416k (284k/393k), time: 21291.73/25.22/ 0.17 I/O read: 89MB, write: 19MB, rate: 0.01MB/s 178 bad blocks marked!","tags":"Admin","title":"Eliminarea blocurilor Bad pe partitiile EXT4"}]}